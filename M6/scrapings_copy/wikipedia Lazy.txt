"Lazy", by The Vaccines and Kylie Minogue for A Shaun the Sheep Movie: Farmageddon, 2019
Lazy (Orlová), a former village now part of the town of Orlová in the Czech Republic
Lazy, an American band featuring former members of the Supreme Beings of Leisure
This page was last edited on 13 January 2023, at 16:13 (UTC).
Doug Lazy, stage name of American hip hop and dance music producer and DJ Gene Douglas Finley
Lazy is the adjective for laziness, a lack of desire to expend effort.
^ a b Douglas W. Jones, CS:2820 Notes, Fall 2020, Lecture 25, retrieved Jan. 2021.
Douglas W. Jones, CS:2820 Notes, Fall 2020, Lecture 25, retrieved Jan. 2021.
Grzegorz Piwowarek, Leveraging Lambda Expressions for Lazy Evaluation in Java, 4Comprehension, July 25, 2018.
^ a b Grzegorz Piwowarek, Leveraging Lambda Expressions for Lazy Evaluation in Java, 4Comprehension, July 25, 2018.
// the output is [0n, 1n, 1n, 2n, 3n, 5n, 8n, 13n, 21n, 34n]
These have the usual semantics, i.e. ifThenElse a b c evaluates (a), then if and only if (a) evaluates to true does it evaluate (b), otherwise it evaluates (c). That is, exactly one of (b) or (c) will be evaluated. Similarly for EasilyComputed || LotsOfWork, if the easy part gives True the lots of work expression could be avoided. Finally, when evaluating SafeToTry && Expression, if SafeToTry is false there will be no attempt at evaluating the Expression.
Launchbury, John (1993). "A natural semantics for lazy evaluation". Proceedings of the 20th ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '93. pp. 144–154. doi:10.1145/158511.158618. ISBN 0897915607. S2CID 14945994.
In lazy programming languages such as Haskell, although the default is to evaluate expressions only when they are demanded, it is possible in some cases to make code more eager—or conversely, to make it more lazy again after it has been made more eager. This can be done by explicitly coding something which forces evaluation (which may make the code more eager) or avoiding such code (which may make the code more lazy). Strict evaluation usually implies eagerness, but they are technically different concepts.
From version 2.2 forward, Python manifests lazy evaluation by implementing iterators (lazy sequences) unlike tuple or list sequences. For instance (Python 2):
"Out of memory when assigning values to existing arrays? - MATLAB Answers - MATLAB Central".
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}David Anthony Watt; William Findlay (2004). Programming language design concepts. John Wiley and Sons. pp. 367–368. ISBN 978-0-470-85320-7. Retrieved 30 December 2010.
"Out of memory when assigning values to existing arrays? - MATLAB Answers - MATLAB Central"
^ a b Philip Wadler (2006). Functional and logic programming: 8th international symposium, FLOPS 2006, Fuji-Susono, Japan, April 24-26, 2006 : proceedings. Springer. p. 149. ISBN 978-3-540-33438-5. Retrieved 14 January 2011.
In the function .mw-parser-output .monospaced{font-family:monospace,monospace}numberFromInfiniteList, the value of infinity is an infinite range, but until an actual value (or more specifically, a specific value at a certain index) is needed, the list is not evaluated, and even then it is only evaluated as needed (that is, until the desired index.) Provided the programmer is careful, the program completes normally. However, certain calculations may result in the program attempting to evaluate an infinite number of elements; for example, requesting the length of the list or trying to sum the elements of the list with a fold operation would result in the program either failing to terminate or running out of memory.
^ a b Daniel Le Métayer (2002). Programming languages and systems: 11th European Symposium on Programming, ESOP 2002, held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2002, Grenoble, France, April 8-12, 2002 : proceedings. Springer. pp. 129–132. ISBN 978-3-540-43363-7. Retrieved 14 January 2011.
^ Hamer-Hodges, Kenneth (1 Jan 2020). Civilizing Cyberspace: The Fight for Digital Democracy. p. 410. ISBN 978-1-95-163044-7. Retrieved 29 February 2020.
The Lazy interface with its eval() method is equivalent to the Supplier interface with its get() method in the java.util.function library.[26]
Bentley, Jon Louis. Writing Efficient Programs. Prentice-Hall, 1985. ISBN 978-0139702440
Friedman, D. P.; Wise, David S. (1976).S. Michaelson; R. Milner (eds.). "Cons should not evaluate its arguments" (PDF). Automata Languages and Programming Third International Colloquium. Edinburgh University Press.
Reynolds, John C. (1998). Theories of programming languages. Cambridge University Press. ISBN 9780521594141. Retrieved 2016-02-23.
In Haskell, marking constructor fields strict means that their values will always be demanded immediately. The seq function can also be used to demand a value immediately and then pass it on, which is useful if a constructor field should generally be lazy. However, neither of these techniques implements recursive strictness—for that, a function called deepSeq was invented.
^ a b Java lambda expressions are not exactly equivalent to anonymous classes, see Anonymous function#Differences_to_Anonymous_Classes
Hudak, Paul (September 1989). "Conception, Evolution, and Application of Functional Programming Languages". ACM Computing Surveys. 21 (3): 383–385. doi:10.1145/72551.72554. S2CID 207637854.
^ "Out of memory when assigning values to existing arrays? - MATLAB Answers - MATLAB Central".
The number of beta reductions to reduce a lambda term with call-by-need is no larger than the number needed by call-by-value or call-by-name reduction.[17][18] And with certain programs the number of steps may be much smaller, for example a specific family of lambda terms using Church numerals take an infinite amount of steps with call-by-value (i.e. never complete), an exponential number of steps with call-by-name, but only a polynomial number with call-by-need. Call-by-need embodies two optimizations - never repeat work (similar to call-by-value), and never perform unnecessary work (similar to call-by-name).[19] Lazy evaluation can also lead to reduction in memory footprint, since values are created when needed.[20]
The ability to define partially-defined data structures where some elements are errors. This allows for rapid prototyping.
* Generator functions return generator objects, which reify lazy evaluation.
^ Niehren, Joachim (1996). "Functional computation as concurrent computation" (PDF). Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages- POPL '96: 333–343. doi:10.1145/237721.237801.
The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.
Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.
Lazy evaluation is often combined with memoization, as described in Jon Bentley's Writing Efficient Programs.[4] After a function's value is computed for that parameter or set of parameters, the result is stored in a lookup table that is indexed by the values of those parameters; the next time the function is called, the table is consulted to determine whether the result for that combination of parameter values is already available. If so, the stored result is simply returned. If not, the function is evaluated and another entry is added to the lookup table for reuse.
^ Niehren, Joachim (September 2000). "Uniform confluence in concurrent computation". Journal of Functional Programming. 10 (5): 453–499. doi:10.1017/S0956796800003762. Retrieved 7 January 2022.
In Python 2.x is possible to use a function called xrange() which returns an object that generates the numbers in the range on demand. The advantage of xrange is that generated object will always take the same amount of memory.
Association for Computing Machinery; ACM Special Interest Group on Programming Languages (1 January 2002). Proceedings of the 2002 ACM SIGPLAN Haskell Workshop (Haskell '02): Pittsburgh, Pennsylvania, USA ; October 3, 2002. Association for Computing Machinery. p. 40. ISBN 978-1-58113-605-0. Retrieved 14 January 2011.
In the above, the variable a initially refers to a lazy integer object created by the lambda expression () -> 1.Evaluating this lambda expression is similar[a] to constructing a new instance of an anonymous class that implements Lazy with an eval method returning 1.
^ a b Stelle, George Widgery (July 2019). Shared-Environment Call-by-Need (PhD). University of New Mexico. pp. 11–12. Retrieved 8 January 2022.
Henderson, Peter; Morris, James H. (1976). "A lazy evaluator". Proceedings of the 3rd ACM SIGACT-SIGPLAN symposium on Principles on programming languages - POPL '76. pp. 95–103. doi:10.1145/800168.811543. S2CID 1228296.
"The Haskell 98 Report: Standard Prelude". www.haskell.org. Boolean functions. Retrieved 8 January 2022.
Philip Wadler (2006). Functional and logic programming: 8th international symposium, FLOPS 2006, Fuji-Susono, Japan, April 24-26, 2006 : proceedings. Springer. p. 149. ISBN 978-3-540-33438-5. Retrieved 14 January 2011.
Lazy Evaluationin ANSI C++ by writing code in a style which uses classes to implement function closures.
This page was last edited on 26 January 2023, at 10:25 (UTC).
In computer windowing systems, the painting of information to the screen is driven by expose events which drive the display code at the last possible moment. By doing this, windowing systems avoid computing unnecessary display content updates.[15]
MATLAB implements copy on edit, where arrays which are copied have their actual memory storage replicated only when their content is changed, possibly leading to an out of memory error when updating an element afterwards instead of during the copy operation.[16]
Conversely, in an eager language the above definition for ifThenElse a b c would evaluate (a), (b), and (c) regardless of the value of (a). This is not the desired behavior, as (b) or (c) may have side effects, take a long time to compute, or throw errors. It is usually possible to introduce user-defined lazy control structures in eager languages as functions, though they may depart from the language's syntax for eager evaluation: Often the involved code bodies need to be wrapped in a function value, so that they are executed only when called.
^ a b Association for Computing Machinery; ACM Special Interest Group on Programming Languages (1 January 2002). Proceedings of the 2002 ACM SIGPLAN Haskell Workshop (Haskell '02): Pittsburgh, Pennsylvania, USA ; October 3, 2002. Association for Computing Machinery. p. 40. ISBN 978-1-58113-605-0. Retrieved 14 January 2011.
In Python 2.x the range() function[27] computes a list of integers. The entire list is stored in memory when the first assignment statement is evaluated, so this is an example of eager or immediate evaluation:
Hamer-Hodges, Kenneth (1 Jan 2020). Civilizing Cyberspace: The Fight for Digital Democracy. p. 410. ISBN 978-1-95-163044-7. Retrieved 29 February 2020.
In Haskell syntax, ":" prepends an element to a list, tail returns a list without its first element, and zipWith uses a specified function (in this case addition) to combine corresponding elements of two lists to produce a third.[13]
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}David Anthony Watt; William Findlay (2004). Programming language design concepts. John Wiley and Sons. pp. 367–368. ISBN 978-0-470-85320-7. Retrieved 30 December 2010.
Niehren, Joachim (September 2000). "Uniform confluence in concurrent computation". Journal of Functional Programming. 10 (5): 453–499. doi:10.1017/S0956796800003762. Retrieved 7 January 2022.
Daniel Le Métayer (2002). Programming languages and systems: 11th European Symposium on Programming, ESOP 2002, held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2002, Grenoble, France, April 8-12, 2002 : proceedings. Springer. pp. 129–132. ISBN 978-3-540-43363-7. Retrieved 14 January 2011.
Proceedings of the 2002 ACM SIGPLAN Haskell Workshop (Haskell '02): Pittsburgh, Pennsylvania, USA ; October 3, 2002
// create the initial state (e.g. a vector of "negafibonacci" numbers)
In programming language theory, lazy evaluation, or call-by-need,[1] is an evaluation strategy which delays the evaluation of an expression until its value is needed (non-strict evaluation) and which also avoids repeated evaluations (sharing).[2][3]
In Python 3.x the range() function[28] returns a generator which computes elements of the list on demand. Elements are only generated when they are needed (e.g., when print(r[3]) is evaluated in the following example), so this is an example of lazy or deferred evaluation:
Delayed evaluation is used particularly in functional programming languages. When using delayed evaluation, an expression is not evaluated as soon as it gets bound to a variable, but when the evaluator is forced to produce the expression's value. That is, a statement such as x = expression; (i.e. the assignment of the result of an expression to a variable) clearly calls for the expression to be evaluated and the result placed in x, but what actually is in x is irrelevant until there is a need for its value via a reference to x in some later expression whose evaluation could itself be deferred, though eventually the rapidly growing tree of dependencies would be pruned to produce some symbol rather than another for the outside world to see.[10]
In C# and VB.NET, the class System.Lazy is directly used.
In practice, lazy evaluation may cause significant performance issues compared to eager evaluation. For example, on modern computer architectures, delaying a computation and performing it later is slower than performing it immediately. This can be alleviated through strictness analysis.[19] Lazy evaluation can also introduce memory leaks due to unevaluated expressions.[21][22]
This allows the previous example to be rewritten to be far more efficient.Where the original ran in time exponential in the number of iterations, the memoized version runs in linear time:
Incremental computing – a related concept whereby computations are only repeated if their inputs change. May be combined with lazy evaluation.
Niehren, Joachim (1996). "Functional computation as concurrent computation" (PDF). Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages- POPL '96: 333–343. doi:10.1145/237721.237801.
Lazy evaluation allows control structures to be defined normally, and not as primitives or compile-time techniques. For example one can define if-then-else and short-circuit evaluation operators:[11][12]
// yield the next value and suspend execution until resumed
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Programming languages and systems: 11th European Symposium on Programming, ESOP 2002, held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2002, Grenoble, France, April 8-12, 2002 : proceedings
However, there is an optimisation implemented in some compilers called strictness analysis, which, in some cases, allows the compiler to infer that a value will always be used. In such cases, this may render the programmer's choice of whether to force that particular value or not, irrelevant, because strictness analysis will force strict evaluation.
Note that Java's lambda expressions are just syntactic sugar.Anything you can write with a lambda expression can be rewritten as a call to construct an instance of an anonymous inner class implementing the interface,[a] and any use of an anonymous inner class can be rewritten using a named inner class, and any named inner class can be moved to the outermost nesting level.
Each iteration of the loop links a to a new object created by evaluating the lambda expression inside the loop.Each of these objects holds a reference to another lazy object, b, and has an eval method that calls b.eval() twice and returns the sum.The variable b is needed here to meet Java's requirement that variables referenced from within a lambda expression be effectively final.
Chris Smith (22 October 2009). Programming F#. O'Reilly Media, Inc. p. 79. ISBN 978-0-596-15364-9. Retrieved 31 December 2010.
Functional and logic programming: 8th international symposium, FLOPS 2006, Fuji-Susono, Japan, April 24-26, 2006 : proceedings
2Applications											Toggle Applications subsection																					2.1Control structures																											2.2Working with infinite data structures																											2.3List-of-successes pattern																											2.4Other uses
Each class that implements the Lazy interface must provide an eval method, and instances of the class may carry whatever values the method needs to accomplish lazy evaluation.For example, consider the following code to lazily compute and print 210:
Delayed evaluation has the advantage of being able to create calculable infinite lists without infinite loops or size matters interfering in computation. The actual values are only computed when needed.For example, one could create a function that creates an infinite list (often called a stream) of Fibonacci numbers. The calculation of the n-th Fibonacci number would be merely the extraction of that element from the infinite list, forcing the evaluation of only the first n members of the list.[13][14]
As another example, the list of all Fibonacci numbers can be written in the Haskell programming language as:[14]
In Java, lazy evaluation can be done by using objects that have a method to evaluate them when the value is needed.The body of this method must contain the code required to perform this evaluation.Since the introduction of lambda expressions in Java SE8, Java has supported a compact notation for this. The following example generic interface provides a framework for lazy evaluation:[24][25]
Stelle, George Widgery (July 2019). Shared-Environment Call-by-Need (PhD). University of New Mexico. pp. 11–12. Retrieved 8 January 2022.
Laziness can be useful for high performance scenarios. An example is the Unix mmap function, which provides demand driven loading of pages from disk, so that only those pages actually touched are loaded into memory, and unneeded memory is not allocated.
5Laziness and eagerness											Toggle Laziness and eagerness subsection																					5.1Controlling eagerness in lazy languages																											5.2Simulating laziness in eager languages																								5.2.1Java																											5.2.2JavaScript																											5.2.3Python																											5.2.4.NET Framework
Lazy evaluation was introduced for lambda calculus by Christopher Wadsworth[5] and employed by the Plessey System 250 as a critical part of a Lambda-Calculus Meta-Machine, reducing the resolution overhead for access to objects in a capability-limited address space.[6] For programming languages, it was independently introduced by Peter Henderson and James H. Morris[7] and by Daniel P. Friedman and David S. Wise.[8][9]
"This can take some time. Do you really want to calculate this large number? [y/n]"
^ "The Haskell 98 Report: Standard Prelude". www.haskell.org. Boolean functions. Retrieved 8 January 2022.
Also, pattern matching in Haskell 98 is strict by default, so the ~ qualifier has to be used to make it lazy.[23]
^ a b Lazy and Speculative Execution Butler Lampson Microsoft Research OPODIS, Bordeaux, France 12 December 2006
In the .NET Framework it is possible to do lazy evaluation using the class System.Lazy.[29] The class can be easily exploited in F# using the lazy keyword, while the force method will force the evaluation. There are also specialized collections like Microsoft.FSharp.Collections.Seq that provide built-in support for lazy evaluation.
Lazy and Speculative Execution Butler Lampson Microsoft Research OPODIS, Bordeaux, France 12 December 2006
^ Chris Smith (22 October 2009). Programming F#. O'Reilly Media, Inc. p. 79. ISBN 978-0-596-15364-9. Retrieved 31 December 2010.
Java lambda expressions are not exactly equivalent to anonymous classes, see Anonymous function#Differences_to_Anonymous_Classes
Another example of laziness in modern computer systems is copy-on-write page allocation or demand paging, where memory is allocated only when a value stored in that memory is changed.[15]
In JavaScript, lazy evaluation can be simulated by using a generator. For example, the stream of all Fibonacci numbers can be written, using memoization, as:
^ Bentley, Jon Louis. Writing Efficient Programs. Prentice-Hall, 1985. ISBN 978-0139702440
This is an inefficient program because this implementation of lazy integers does not memoize the result of previous calls to eval.It also involves considerable autoboxing and unboxing. What may not be obvious is that, at the end of the loop, the program has constructed a linked list of 11 objects and that all of the actual additions involved in computing the result are done in response to the call to a.eval() on the final line of code.This call recursively traverses the list to perform the necessary additions.
Lazy evaluation is difficult to combine with imperative features such as exception handling and input/output, because the order of operations becomes indeterminate.
5.2Simulating laziness in eager languages																								5.2.1Java																											5.2.2JavaScript																											5.2.3Python																											5.2.4.NET Framework
We can build a Java class that memoizes a lazy objects as follows:[24][25]
The ability to define control flow (structures) as abstractions instead of primitives.
^ Piątkowski, Kazimierz (1918). Stosunki narodowościowe w Księstwie Cieszyńskiem (in Polish). Cieszyn: Macierz Szkolna Księstwa Cieszyńskiego. pp. 273, 290.
Zahradnik, Stanisław (1991). Struktura narodowościowa Zaolzia na podstawie spisów ludności 1880-1991. Trzyniec: HT. OCLC 189422554.
Schulte, Wilhelm (1889). Codex Diplomaticus Silesiae T.14 Liber Fundationis Episcopatus Vratislaviensis (in German). Breslau.
Piątkowski, Kazimierz (1918). Stosunki narodowościowe w Księstwie Cieszyńskiem (in Polish). Cieszyn: Macierz Szkolna Księstwa Cieszyńskiego. pp. 273, 290.
The settlement was first mentioned in a Latin document of Diocese of Wrocław called Liber fundationis episcopatus Vratislaviensis from around 1305 as item in Lazy villa Paczconis.[3][4][5]It meant that the village was in the process of location (the size of land to pay a tithe from was not yet precise). The village could have been founded by Benedictine monks from an Orlová abbey[6] and also it could a part of a larger settlement campaign taking place in the late 13th century on the territory of what would later be known as Upper Silesia.
"Ustawa z dnia 27 października 1938 r. o podziale administracyjnym i tymczasowej organizacji administracji na obszarze Ziem Odzyskanych Śląska Cieszyńskiego". Dziennik Ustaw Śląskich (in Polish). Katowice. nr 18/1938, poz. 35. 31 October 1938. Retrieved 1 July 2014.
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Mrózek, Robert (1984). Nazwy miejscowe dawnego Śląska Cieszyńskiego [Local names of former Cieszyn Silesia] (in Polish). Katowice: Uniwersytet Śląski w Katowicach. p. 110. ISSN 0208-6336.
The name is cultural in origin and in Polish denotes an arable area obtained by slash-and-burn technique.[2]
^ "Liber fundationis episcopatus Vratislaviensis" (in Latin). Retrieved 13 July 2014.
This page was last edited on 29 January 2023, at 01:39 (UTC).
^ Panic, Idzi (2010). Śląsk Cieszyński w średniowieczu (do 1528) [Cieszyn Silesia in Middle Ages (until 1528)] (in Polish). Cieszyn: Starostwo Powiatowe w Cieszynie. pp. 297–299. ISBN 978-83-926929-3-5.
After the Revolutions of 1848 in the Austrian Empire, a modern municipal division was introduced in the re-established Austrian Silesia. The village as a municipality was subscribed at least since 1880 to political district and legal district of Freistadt.
According to the censuses conducted in 1880, 1890, 1900 and 1910 the population of the municipality grew from 1,516 in 1880 to 7,896 in 1910. In 1880 the majority were Czech-speaking (893 or 59.7%), followed by Polish-speaking (577 or 38.6%), in 1890 it changed so that the majority became Polish-speaking (1,507 or 70.3%, and then in 1900 4,660 or 81.7%) with Czech-speaking minority (622 or 29% in 1890 and 921 or 16.1% in 1900). This again shifted in 1910, when 49% where Czech-speaking and 48.7% Polish-speaking. They were accompanied by a small German-speaking minority (between 15 or 0.7% in 1890 and 181 or 2.3% in 1910). In terms of religion, in 1910 the majority were Roman Catholics (72.4%), followed by Protestants (26%), Jews (115 or 1.5%), and others (15 or 0.1%).[7]
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Mrózek, Robert (1984). Nazwy miejscowe dawnego Śląska Cieszyńskiego [Local names of former Cieszyn Silesia] (in Polish). Katowice: Uniwersytet Śląski w Katowicach. p. 110. ISSN 0208-6336.
Lazy (help·info) (Polish: Łazy) is a village in Karviná District, Moravian-Silesian Region, Czech Republic. It was a separate municipality but became administratively a part of Orlová in 1946. It has a population of 274.[1]
Politically the village belonged initially to the Duchy of Teschen, formed in 1290 in the process of feudal fragmentation of Poland and was ruled by a local branch of Silesian Piast dynasty. In 1327 the duchy became a fee of the Kingdom of Bohemia, which after 1526 became part of the Habsburg monarchy.
After World War I, the fall of Austria-Hungary, the Polish–Czechoslovak War and the division of Cieszyn Silesia in 1920, the village became a part of Czechoslovakia. Following the Munich Agreement, in October 1938 together with the Zaolzie region it was annexed by Poland, administratively organised in Frysztat County of Silesian Voivodeship.[8] The village was then annexed by Nazi Germany at the beginning of World War II. After the war it was restored to Czechoslovakia.
"Liber fundationis episcopatus Vratislaviensis" (in Latin). Retrieved 13 July 2014.
^ Schulte, Wilhelm (1889). Codex Diplomaticus Silesiae T.14 Liber Fundationis Episcopatus Vratislaviensis (in German). Breslau.
Coordinates: .mw-parser-output .geo-default,.mw-parser-output .geo-dms,.mw-parser-output .geo-dec{display:inline}.mw-parser-output .geo-nondefault,.mw-parser-output .geo-multi-punct{display:none}.mw-parser-output .longitude,.mw-parser-output .latitude{white-space:nowrap}49°50′20″N 18°25′6″E﻿ / ﻿49.83889°N 18.41833°E﻿ / 49.83889; 18.41833
"Ustawa z dnia 27 października 1938 r. o podziale administracyjnym i tymczasowej organizacji administracji na obszarze Ziem Odzyskanych Śląska Cieszyńskiego"
Panic, Idzi (2010). Śląsk Cieszyński w średniowieczu (do 1528) [Cieszyn Silesia in Middle Ages (until 1528)] (in Polish). Cieszyn: Starostwo Powiatowe w Cieszynie. pp. 297–299. ISBN 978-83-926929-3-5.
^ "Ustawa z dnia 27 października 1938 r. o podziale administracyjnym i tymczasowej organizacji administracji na obszarze Ziem Odzyskanych Śląska Cieszyńskiego". Dziennik Ustaw Śląskich (in Polish). Katowice. nr 18/1938, poz. 35. 31 October 1938. Retrieved 1 July 2014.
