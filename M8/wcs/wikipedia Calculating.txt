This page was last edited on 15 July 2019, at 13:23 (UTC).
Statistical estimations of the likely election results from opinion polls also involve algorithmic calculations, but produces ranges of possibilities rather than exact answers.
"calculate | Definition of calculate in English by Oxford Dictionaries"
Calculus (disambiguation) — list of general methods of calculation by application area
A calculation is a deliberate mathematical process that transforms one or more inputs into one or more outputs or results. The term is used in a variety of senses, from the very definite arithmetical calculation of using an algorithm, to the vague heuristics of calculating a strategy in a competition, or calculating the chance of a successful relationship between two people.
Find sources: "Calculation" – news · newspapers · books · scholar · JSTOR
List of algorithms — fully formalized, computer-executable methods of calculation
This page was last edited on 5 March 2023, at 07:19 (UTC).
To calculate means to determine mathematically in the case of a number or amount, or in the case of an abstract problem to deduce the answer using logic, reason or common sense.[1] The English word derives from the Latin calculus, which originally meant a small stone in the gall-bladder (from Latin calx). It also meant a pebble used for calculating, or a small stone used as a counter in an abacus (Latin abacus, Greek abax). The abacus was an instrument used by Greeks and Romans for arithmetic calculations, preceding the slide-rule and the electronic calculator, and consisted of perforated pebbles sliding on iron bars.
"The Lifting of the Veil in the Operations of Calculation" is a manuscript, from the 18th-century, in Arabic, by Ibn al-Banna' al-Marrakushi, about calculation processes
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"calculate | Definition of calculate in English by Oxford Dictionaries". Oxford Dictionaries | English. Archived from the original on August 31, 2018. Retrieved 2018-08-30.
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"calculate | Definition of calculate in English by Oxford Dictionaries". Oxford Dictionaries | English. Archived from the original on August 31, 2018. Retrieved 2018-08-30.
dividenddivisor numeratordenominator}={\displaystyle \scriptstyle \left.{\begin{matrix}\scriptstyle {\frac {\scriptstyle {\text{dividend}}}{\scriptstyle {\text{divisor}}}}\\\scriptstyle {\text{ }}\\\scriptstyle {\frac {\scriptstyle {\text{numerator}}}{\scriptstyle {\text{denominator}}}}\end{matrix}}\right\}\,=\,}
For example, multiplying 7 by 6 is a simple algorithmic calculation. Extracting the square root or the cube root of a number using mathematical models is a more complex algorithmic calculation.
Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: "Calculation" – news · newspapers · books · scholar · JSTOR
"The Lifting of the Veil in the Operations of Calculation"
^ Giunti, Marco (1997). Computation, Dynamics, and Cognition. New York: Oxford University Press. ISBN 978-0-19-509009-3.
Giunti, Marco (1997). Computation, Dynamics, and Cognition. New York: Oxford University Press. ISBN 978-0-19-509009-3.
State models including Turing machine, pushdown automaton, finite state automaton, and PRAM
Mechanical or electronic devices (or, historically, people) that perform computations are known as computers. An especially well-known discipline of the study of computation is computer science.
This point of view has been adopted by the physics of computation, a branch of theoretical physics, as well as the field of natural computing.
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Computation: Definition and Synonyms from Answers.com". Answers.com. Archived from the original on 22 February 2009. Retrieved 26 April 2017.
An even more radical point of view, pancomputationalism, is the postulate of digital physics that argues that the evolution of the universe is itself a computation.
Piccinini, Gualtiero (2015). Physical Computation: A Mechanistic Account. Oxford: Oxford University Press. p. 10. ISBN 9780199658855.
Please improve it by verifying the claims made and adding inline citations. Statements consisting only of original research should be removed.
1Physical process of computation											Toggle Physical process of computation subsection																					1.1The mapping account																											1.2The semantic account																											1.3The mechanistic account
Gualtiero Piccinini proposes an account of computation based on mechanical philosophy. It states that physical computing systems are types of mechanisms that, by design, perform physical computation, or the manipulation (by a functional mechanism) of a "medium-independent" vehicle according to a rule. "Medium-independence" requires that the property can be instantiated[clarification needed] by multiple realizers[clarification needed] and multiple mechanisms, and that the inputs and outputs of the mechanism also be multiply realizable. In short, medium-independence allows for the use of physical variables with properties other than voltage (as in typical digital computers); this is imperative in considering other types of computation, such as that which occurs in the brain or in a quantum computer. A rule, in this sense, provides a mapping among inputs, outputs, and internal states of the physical computing system.[6]
Piccinini, Gualtiero (2015). Physical Computation: A Mechanistic Account. Oxford: Oxford University Press. p. 18. ISBN 9780199658855.
Philosophers such as Jerry Fodor[5] have suggested various accounts of computation with the restriction that semantic content be a necessary condition for computation (that is, what differentiates an arbitrary physical system from a computing system is that the operands of the computation represent something).This notion attempts to prevent the logical abstraction of the mapping account of pancomputationalism, the idea that everything can be said to be computing everything.
^ Godfrey-Smith, P. (2009), "Triviality Arguments against Functionalism", Philosophical Studies, 145 (2): 273–95, doi:10.1007/s11098-008-9231-3, S2CID 73619367
Giunti calls the models studied by computation theory computational systems, and he argues that all of them are mathematical dynamical systems with discrete time and discrete state space.[7]: ch.1  He maintains that a computational system is a complex object which consists of three parts. First, a mathematical dynamical system DS{\displaystyle DS} with discrete time and discrete state space; second, a computational setup H=(F,BF){\displaystyle H=\left(F,B_{F}\right)}, which is made up of a theoretical part F{\displaystyle F}, and a real part BF{\displaystyle B_{F}}; third, aninterpretation IDS,H{\displaystyle I_{DS,H}}, which links the dynamical system DS{\displaystyle DS} with the setup H{\displaystyle H}.[8]: pp.179–80
This page was last edited on 27 February 2023, at 15:06 (UTC).
^ Giunti, Marco (2017), "What is a Physical Realization of a Computational System?", Isonomia -- Epistemologica, 9: 177–92, ISSN 2037-4348
The classic account of computation is found throughout the works of Hilary Putnam and others. Peter Godfrey-Smith has dubbed this the "simple mapping account."[3] Gualtiero Piccinini's summary of this account states that a physical system can be said to perform a specific computation when there is a mapping between the state of that system and the computation such that the "microphysical states [of the system] mirror the state transitions between the computational states."[4]
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Computation: Definition and Synonyms from Answers.com". Answers.com. Archived from the original on 22 February 2009. Retrieved 26 April 2017.
Computation can be seen as a purely physical process occurring inside a closed physical system called a computer. Examples of such physical systems are digital computers, mechanical computers, quantum computers, DNA computers, molecular computers, microfluidics-based computers, analog computers, and wetware computers.
Fodor, J. A. (1986), "The Mind-Body Problem", Scientific American, 244 (January 1986)
Godfrey-Smith, P. (2009), "Triviality Arguments against Functionalism", Philosophical Studies, 145 (2): 273–95, doi:10.1007/s11098-008-9231-3, S2CID 73619367
^ Fodor, J. A. (1986), "The Mind-Body Problem", Scientific American, 244 (January 1986)
In the theory of computation, a diversity of mathematical models of computation has been developed.Typical mathematical models of computers are the following:
Giunti, Marco (2017), "What is a Physical Realization of a Computational System?", Isonomia -- Epistemologica, 9: 177–92, ISSN 2037-4348
^ Piccinini, Gualtiero (2015). Physical Computation: A Mechanistic Account. Oxford: Oxford University Press. p. 10. ISBN 9780199658855.
^ Piccinini, Gualtiero (2015). Physical Computation: A Mechanistic Account. Oxford: Oxford University Press. p. 18. ISBN 9780199658855.
Computation is any type of arithmetic or non-arithmetic calculation that follows a well-defined model (e.g., an algorithm).[1][2]
^ Gigerenzer, Gerd; Brighton, Henry (2009). "Homo Heuristicus: Why Biased Minds Make Better Inferences". Topics in Cognitive Science. 1 (1): 107–143. doi:10.1111/j.1756-8765.2008.01006.x. hdl:11858/00-001M-0000-0024-F678-0. ISSN 1756-8765. PMID 25164802.
^ Groner, Rudolf; Groner, Marina; Bischof, Walter F. (1983). Methods of Heuristics. Hillsdale, NJ: Lawrence Erlbaum.
This is because only the general problem can provide to a specific problem—a context from which to draw meaning.
^ Hutchinson, John M. C.; Gigerenzer, Gerd (2005-05-31). "Simple heuristics and rules of thumb: Where psychologists and behavioural biologists might meet". Behavioural Processes. Proceedings of the meeting of the Society for the Quantitative Analyses of Behavior (SQAB 2004). 69 (2): 97–124. doi:10.1016/j.beproc.2005.02.019. ISSN 0376-6357. PMID 15845293. S2CID 785187.
Try solving a more general problem first (the "inventor's paradox": the more ambitious plan may have more chances of success).
Johnson, Eric E. (2006). "Calibrating Patent Lifetimes" (PDF). Santa Clara Computer & High Technology Law Journal. 22: 269–314. Archived from the original (PDF) on 2011-10-05.
A heuristic can be used in artificial intelligence systems while searching a solution space. The heuristic is derived by using some function that is put into the system by the designer, or by adjusting the weight of branches based on how likely each branch is to lead to a goal node.
Gigerenzer, Gerd; Gaissmaier, Wolfgang (2011). "Heuristic Decision Making". Annual Review of Psychology. 62 (1): 451–482. doi:10.1146/annurev-psych-120709-145346. hdl:11858/00-001M-0000-0024-F16D-5. PMID 21126183.
Heuristic (/hjʊˈrɪstɪk/; from Ancient Greekεὑρίσκω (heurískō) 'I find, discover'), or heuristic technique, is any approach to problem solving or self-discovery that employs a practical method that is not guaranteed to be optimal, perfect, or rational, but is nevertheless sufficient for reaching an immediate, short-term goal or approximation. Where finding an optimal solution is impossible or impractical, heuristic methods can be used to speed up the process of finding a satisfactory solution. Heuristics can be mental shortcuts that ease the cognitive load of making a decision.[1][2]
Rudolf Groner analysed the history of heuristics from its roots in ancient Greece up to contemporary work in cognitive psychology and artificial intelligence,[10] proposing a cognitive style "heuristic versus algorithmic thinking", which can be assessed by means of a validated questionnaire.[11]
^ Epstein, S.; Pacini, R.; Denes-Raj, V.; Heier, H. (1996). "Individual differences in intuitive-experiential and analytical-rational thinking styles". Journal of Personality and Social Psychology. 71 (2): 390–405. doi:10.1037/0022-3514.71.2.390. PMID 8765488.
Gigerenzer, Gerd (1991). "How to Make Cognitive Illusions Disappear: Beyond "Heuristics and Biases"" (PDF). European Review of Social Psychology. 2: 83–115. CiteSeerX 10.1.1.336.9826. doi:10.1080/14792779143000033. Retrieved 14 October 2012.
The present securities regulation regime largely assumes that all investors act as perfectly rational persons.In truth, actual investors face cognitive limitations from biases, heuristics, and framing effects. For instance, in all states in the United States the legal drinking age for unsupervised persons is 21 years, because it is argued that people need to be mature enough to make decisions involving the risks of alcohol consumption. However, assuming people mature at different rates, the specific age of 21 would be too late for some and too early for others. In this case, the somewhat arbitrary delineation is used because it is impossible or impractical to tell whether an individual is sufficiently mature for society to trust them with that kind of responsibility. Some proposed changes, however, have included the completion of an alcohol education course rather than the attainment of 21 years of age as the criterion for legal alcohol possession. This would put youth alcohol policy more on a case-by-case basis and less on a heuristic one, since the completion of such a course would presumably be voluntary and not uniform across the population.
Cioffi, Jane (1997). "Heuristics, servants to intuition, in clinical decision making". Journal of Advanced Nursing. 26 (1): 203–208. doi:10.1046/j.1365-2648.1997.1997026203.x. PMID 9231296.
Gökçen, Sinan (20 November 2007). "Pictures in Our Heads". European Roma Rights Centre. Retrieved 24 March 2015.
Pólya, George (1945) How to Solve It: A New Aspect of Mathematical Method, Princeton, NJ: Princeton University Press. ISBN 0-691-02356-5 ISBN 0-691-08097-6
Sunstein, Cass (2005). "Moral Heuristics". The Behavioral and Brain Sciences. 28 (4): 531–542. doi:10.1017/S0140525X05000099. PMID 16209802. S2CID 231738548.
^ Johnson, Eric E. (2006). "Calibrating Patent Lifetimes" (PDF). Santa Clara Computer & High Technology Law Journal. 22: 269–314. Archived from the original (PDF) on 2011-10-05.
^ a b "Heuristics—Explanation and examples". Conceptually. Retrieved 23 October 2019.
If you can't find a solution, try assuming that you have a solution and seeing what you can derive from that ("working backward"). AKA "what shape would it have" aka system-requirements.
Heuristic is also often used as a noun to describe a rule-of-thumb, procedure, or method.[32] Philosophers of science have emphasised the importance of heuristics in creative thought and the construction of scientific theories.[33] Seminal works include Karl Popper's The Logic of Scientific Discovery and others by Imre Lakatos,[34] Lindley Darden, and William C. Wimsatt.
^ Kiss, Olga (2006). "Heuristic, Methodology or Logic of Discovery? Lakatos on Patterns of Thinking". Perspectives on Science. 14 (3): 302–317. doi:10.1162/posc.2006.14.3.302. S2CID 57559578.
^ Lori, Harris (2007). CliffsAP Psychology. John Wiley & Sons. p. 65. ISBN 978-0-470-19718-9.
A good example is a model that, as it is never identical with what it models, is a heuristic device to enable understanding of what it models. Stories, metaphors, etc., can also be termed heuristic in this sense. A classic example is the notion of utopia as described in Plato's best-known work, The Republic. This means that the "ideal city" as depicted in The Republic is not given as something to be pursued, or to present an orientation-point for development. Rather, it shows how things would have to be connected, and how one thing would lead to another (often with highly problematic results), if one opted for certain principles and carried them through rigorously.
Epstein, S.; Pacini, R.; Denes-Raj, V.; Heier, H. (1996). "Individual differences in intuitive-experiential and analytical-rational thinking styles". Journal of Personality and Social Psychology. 71 (2): 390–405. doi:10.1037/0022-3514.71.2.390. PMID 8765488.
Heuristic Reasoning: Studies in Applied Philosophy, Epistemology and Rational Ethics
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Myers, David G. (2010). Social psychology (Tenth ed.). New York, NY: McGraw-Hill. p. 94. ISBN 978-0-07337-066-8. OCLC 667213323.
^ De Neys, Wim (18 October 2008). "Cognitive experiential self theory". Perspectives on Psychological Science. 7 (1): 28–38. doi:10.1177/1745691611429354. PMID 26168420. S2CID 32261626. Archived from the original on 31 July 2013.
In psychology, heuristics are simple, efficient rules, either learned or inculcated by evolutionary processes. These psychological heuristics have been proposed to explain how people make decisions, come to judgements, and solve problems. These rules typically come into play when people face complex problems or incomplete information. Researchers employ various methods to test whether people use these rules. The rules have been shown to work well under most circumstances, but in certain cases can lead to systematic errors or cognitive biases.[7]
De Neys, Wim (18 October 2008). "Cognitive experiential self theory". Perspectives on Psychological Science. 7 (1): 28–38. doi:10.1177/1745691611429354. PMID 26168420. S2CID 32261626. Archived from the original on 31 July 2013.
Lori, Harris (2007). CliffsAP Psychology. John Wiley & Sons. p. 65. ISBN 978-0-470-19718-9.
^ Gigerenzer, Gerd; Brighton, Henry (2009). "Homo heuristicus: why biased minds make better inferences". Topics in Cognitive Science. 1 (1): 107–143. doi:10.1111/j.1756-8765.2008.01006.x. hdl:11858/00-001M-0000-0024-F678-0. ISSN 1756-8765. PMID 25164802.
^ Braun, T.D.; Siegal, H.J.; Beck, N.; Boloni, L.L.; Maheswaran, M.; Reuther, A.I.; Robertson, J.P.; Theys, M.D.; Bin Yao; Hensgen, D.; Freund, R.F. (1999). "A comparison study of static mapping heuristics for a class of meta-tasks on heterogeneous computing systems". Proceedings. Eighth Heterogeneous Computing Workshop (HCW'99). IEEE Comput. Soc: 15–29. doi:10.1109/hcw.1999.765093. hdl:10945/35227. ISBN 0-7695-0107-9. S2CID 2860157.
Pearl, Judea (1983). Heuristics: Intelligent Search Strategies for Computer Problem Solving. New York, NY: Addison-Wesley. p. vii. ISBN 978-0-201-05594-8.
Gigerenzer, Gerd; Engel, Christoph, eds. (2007). Heuristics and the Law. Cambridge, MA: MIT Press. ISBN 978-0-262-07275-5.
Gigerenzer, Gerd; Selten, Reinhard, eds. (2002). Bounded Rationality: The Adaptive Toolbox. Cambridge, MA: MIT Press. ISBN 978-0-26257-164-7.
^ Scholz, R. W. (1983-11-01). Decision Making under Uncertainty: Cognitive Decision Research, Social Interaction, Development and Epistemology. Elsevier. ISBN 978-0-08-086670-3.
^ Pearl, Judea (1983). Heuristics: Intelligent Search Strategies for Computer Problem Solving. New York, NY: Addison-Wesley. p. vii. ISBN 978-0-201-05594-8.
Gerd Gigerenzer and his research group argued that models of heuristics need to be formal to allow for predictions of behavior that can be tested.[12] They study the fast and frugal heuristics in the "adaptive toolbox" of individuals or institutions, and the ecological rationality of these heuristics; that is, the conditions under which a given heuristic is likely to be successful.[13] The descriptive study of the "adaptive toolbox" is done by observation and experiment, the prescriptive study of the ecological rationality requires mathematical analysis and computer simulation. Heuristics – such as the recognition heuristic, the take-the-best heuristic and fast-and-frugal trees – have been shown to be effective in predictions, particularly in situations of uncertainty. It is often said that heuristics trade accuracy for effort but this is only the case in situations of risk. Risk refers to situations where all possible actions, their outcomes and probabilities are known. In the absence of this information, that is under uncertainty, heuristics can achieve higher accuracy with lower effort.[14] This finding, known as a less-is-more effect, would not have been found without formal models. The valuable insight of this program is that heuristics are effective not despite their simplicity — but because of it. Furthermore, Gigerenzer and Wolfgang Gaissmaier found that both individuals and organisations rely on heuristics in an adaptive way.[15]
^ Gigerenzer, Gerd; Selten, Reinhard, eds. (2002). Bounded Rationality: The Adaptive Toolbox. Cambridge, MA: MIT Press. ISBN 978-0-26257-164-7.
A heuristic device is used when an entity X exists to enable understanding of, or knowledge concerning, some other entity Y.
Heuristics is the process by which humans use mental short cuts to arrive at decisions. Heuristics are simple strategies that humans, animals,[21][22][23] organizations,[24] and even machines[25] use to quickly form judgments, make decisions, and find solutions to complex problems. Often this involves focusing on the most relevant aspects of a problem or situation to formulate a solution.[26][27][28][29] While heuristic processes are used to find the answers and solutions that are most likely to work or be correct, they are not always right or the most accurate.[30] Judgments and decisions based on heuristics are simply good enough to satisfy a pressing need in situations of uncertainty, where information is incomplete.[31] In that sense they can differ from answers given by logic and probability.
Kahneman, Daniel (December 2003). "Maps of Bounded Rationality: Psychology for Behavioral Economics" (PDF). American Economic Review. 93 (5): 1449–1475. CiteSeerX 10.1.1.194.6554. doi:10.1257/000282803322655392. ISSN 0002-8282. Archived from the original (PDF) on 19 February 2018.
The Problem of Thinking Too Much, 11 December 2002, Persi Diaconis
^ Goldstein, E. Bruce (2018-07-23). Cognitive psychology : connecting mind, research, and everyday experience. ISBN 978-1-337-40827-1. OCLC 1055681278.
Kiss, Olga (2006). "Heuristic, Methodology or Logic of Discovery? Lakatos on Patterns of Thinking". Perspectives on Science. 14 (3): 302–317. doi:10.1162/posc.2006.14.3.302. S2CID 57559578.
^ Gökçen, Sinan (20 November 2007). "Pictures in Our Heads". European Roma Rights Centre. Retrieved 24 March 2015.
The study of heuristics in human decision-making was developed in the 1970s and the 1980s, by the psychologists Amos Tversky and Daniel Kahneman,[8] although the concept had been originally introduced by the Nobel laureate Herbert A. Simon. Simon's original primary object of research was problem solving that showed that we operate within what he calls bounded rationality. He coined the term satisficing, which denotes a situation in which people seek solutions, or accept choices or judgements, that are "good enough" for their purposes although they could be optimised.[9]
Jaszczolt, K. M. (2006). "Defaults in Semantics and Pragmatics". Stanford Encyclopedia of Philosophy. ISSN 1095-5054.
Goldstein, E. Bruce (2018-07-23). Cognitive psychology : connecting mind, research, and everyday experience. ISBN 978-1-337-40827-1. OCLC 1055681278.
^ Cioffi, Jane (1997). "Heuristics, servants to intuition, in clinical decision making". Journal of Advanced Nursing. 26 (1): 203–208. doi:10.1046/j.1365-2648.1997.1997026203.x. PMID 9231296.
Kleg, Milton (1993). Hate Prejudice and Racism. Albany, NY: State University of New York Press. p. 135. ISBN 978-0-79141-536-8.
^ Marsh, Barnaby (2002-01-01). "Do Animals Use Heuristics?". Journal of Bioeconomics. 4 (1): 49–56. doi:10.1023/A:1020655022163. ISSN 1573-6989. S2CID 142852213.
Examples that employ heuristics include using trial and error, a rule of thumb or an educated guess.
Stereotypes, as first described by journalist Walter Lippmann in his book Public Opinion (1922), are the pictures we have in our heads that are built around experiences as well as what we are told about the world.[38][39]
^ Gigerenzer, Gerd; Hertwig, Ralph; Pachur, Thorsten (15 April 2011). Heuristics: The Foundations of Adaptive Behavior. Oxford University Press. doi:10.1093/acprof:oso/9780199744282.001.0001. hdl:11858/00-001M-0000-0024-F172-8. ISBN 978-0-19989-472-7.
^ Heuristics and heuristic evaluation. Interaction-design.org. Retrieved 1 September 2013.
^ Bodenhausen, Galen V.;et al. (1999). "On the Dialectics of Discrimination: Dual Processes in Social Stereotyping".In Chaiken, Shelly; Trope, Yaacov (eds.). Dual-process Theories in Social Psychology. New York, NY: Guilford Press. pp. 271–292. ISBN 978-1-57230-421-5.
Russell, Stuart J.; Norvig, Peter (2003), Artificial Intelligence: A Modern Approach (2nd ed.), Upper Saddle River, New Jersey: Prentice Hall, ISBN 0-13-790395-2
In legal theory, especially in the theory of law and economics, heuristics are used in the law when case-by-case analysis would be impractical, insofar as "practicality" is defined by the interests of a governing body.[35]
^ Kahneman, Daniel; Slovic, Paul; Tversky, Amos, eds. (30 April 1982). Judgment Under Uncertainty. Cambridge, UK: Cambridge University Press. doi:10.1017/cbo9780511809477. ISBN 978-0-52128-414-1.
^ Gigerenzer, Gerd; Todd, Peter M.; and the ABC Research Group (1999). Simple Heuristics That Make Us Smart. Oxford, UK: Oxford University Press. ISBN 978-0-19512-156-8.
If the problem is abstract, try examining a concrete example.
^ Kleg, Milton (1993). Hate Prejudice and Racism. Albany, NY: State University of New York Press. p. 135. ISBN 978-0-79141-536-8.
1History											Toggle History subsection																					1.1Adaptive toolbox																											1.2Cognitive-experiential self-theory																											1.3Attribute substitution
When experiencing a difficulty in understanding a problem, draw the architecture from all directions e.g. top-view, side-view, front-view.
Marsh, Barnaby (2002-01-01). "Do Animals Use Heuristics?". Journal of Bioeconomics. 4 (1): 49–56. doi:10.1023/A:1020655022163. ISSN 1573-6989. S2CID 142852213.
Hutchinson, John M. C.; Gigerenzer, Gerd (2005-05-31). "Simple heuristics and rules of thumb: Where psychologists and behavioural biologists might meet". Behavioural Processes. Proceedings of the meeting of the Society for the Quantitative Analyses of Behavior (SQAB 2004). 69 (2): 97–124. doi:10.1016/j.beproc.2005.02.019. ISSN 0376-6357. PMID 15845293. S2CID 785187.
^ Gigerenzer, Gerd (1991). "How to Make Cognitive Illusions Disappear: Beyond "Heuristics and Biases"" (PDF). European Review of Social Psychology. 2: 83–115. CiteSeerX 10.1.1.336.9826. doi:10.1080/14792779143000033. Retrieved 14 October 2012.
Alan, Lewis (2018). The Cambridge Handbook of Psychology and Economic Behavior. Cambridge University Press. p. 43. ISBN 978-0-521-85665-2.
^ Gigerenzer, Gerd; Gaissmaier, Wolfgang (January 2011). "Heuristic Decision Making". Annual Review of Psychology. 62: 451–482. doi:10.1146/annurev-psych-120709-145346. hdl:11858/00-001M-0000-0024-F16D-5. PMID 21126183. SSRN 1722019.
Heuristics, through greater refinement and research, have begun to be applied to other theories, or be explained by them. For example, the cognitive-experiential self-theory (CEST) also is an adaptive view of heuristic processing. CEST breaks down two systems that process information. At some times, roughly speaking, individuals consider issues rationally, systematically, logically, deliberately, effortfully and verbally. On other occasions, individuals consider issues intuitively, effortlessly, globally, and emotionally.[16] From this perspective, heuristics are part of a larger experiential processing system that is often adaptive, but vulnerable to error in situations that require logical analysis.[17]
How To Solve It: Modern Heuristics, Zbigniew Michalewicz and David B. Fogel, Springer Verlag, 2000. ISBN 3-540-66061-5
Groner, Rudolf; Groner, Marina (1991). "Heuristische versus algorithmische Orientierung als Dimension des individuellen kognitiven Stils" [Heuristic versus algorithmic orientation as a dimension of the individual cognitive style].In K. Grawe; N. Semmer; R. Hänni (eds.). Über die richtige Art, Psychologie zu betreiben [About the right way to do psychology] (in German). Göttingen: Hogrefe. ISBN 978-3-80170-415-5.
^ Alan, Lewis (2018). The Cambridge Handbook of Psychology and Economic Behavior. Cambridge University Press. p. 43. ISBN 978-0-521-85665-2.
This page was last edited on 7 February 2023, at 18:35 (UTC).
The same reasoning applies to patent law. Patents are justified on the grounds that inventors must be protected so they have incentive to invent. It is therefore argued that it is in society's best interest that inventors receive a temporary government-granted monopoly on their idea, so that they can recoup investment costs and make economic profit for a limited period. In the United States, the length of this temporary monopoly is 20 years from the date the patent application was filed, though the monopoly does not actually begin until the application has matured into a patent. However, like the drinking-age problem above, the specific length of time would need to be different for every product to be efficient. A 20-year term is used because it is difficult to tell what the number should be for any individual patent. More recently, some, including University of North Dakota law professor Eric E. Johnson, have argued that patents in different kinds of industries – such as software patents – should be protected for different lengths of time.[36]
^ Gigerenzer, Gerd; Gaissmaier, Wolfgang (2011). "Heuristic Decision Making". Annual Review of Psychology. 62 (1): 451–482. doi:10.1146/annurev-psych-120709-145346. hdl:11858/00-001M-0000-0024-F16D-5. PMID 21126183.
Gigerenzer, Gerd; Gaissmaier, Wolfgang (January 2011). "Heuristic Decision Making". Annual Review of Psychology. 62: 451–482. doi:10.1146/annurev-psych-120709-145346. hdl:11858/00-001M-0000-0024-F16D-5. PMID 21126183. SSRN 1722019.
Groner, Rudolf; Groner, Marina; Bischof, Walter F. (1983). Methods of Heuristics. Hillsdale, NJ: Lawrence Erlbaum.
Nevid, Jeffery (2008). Psychology: Concepts and Applications. Cengage Learning. p. 251. ISBN 978-0-547-14814-4.
^ Nevid, Jeffery (2008). Psychology: Concepts and Applications. Cengage Learning. p. 251. ISBN 978-0-547-14814-4.
Bodenhausen, Galen V.;et al. (1999). "On the Dialectics of Discrimination: Dual Processes in Social Stereotyping".In Chaiken, Shelly; Trope, Yaacov (eds.). Dual-process Theories in Social Psychology. New York, NY: Guilford Press. pp. 271–292. ISBN 978-1-57230-421-5.
Heuristics are the strategies derived from previous experiences with similar problems. These strategies depend on using readily accessible, though loosely applicable, information to control problem solving in human beings, machines and abstract issues.[3][4] When an individual applies a heuristic in practice, it generally performs as expected. However it can alternatively create systematic errors.[5]
^ Groner, Rudolf; Groner, Marina (1991). "Heuristische versus algorithmische Orientierung als Dimension des individuellen kognitiven Stils" [Heuristic versus algorithmic orientation as a dimension of the individual cognitive style].In K. Grawe; N. Semmer; R. Hänni (eds.). Über die richtige Art, Psychologie zu betreiben [About the right way to do psychology] (in German). Göttingen: Hogrefe. ISBN 978-3-80170-415-5.
^ Jaszczolt, K. M. (2006). "Defaults in Semantics and Pragmatics". Stanford Encyclopedia of Philosophy. ISSN 1095-5054.
^ Frigg, Roman; Hartmann, Stephan (2006). "Models in Science". Stanford Encyclopedia of Philosophy. ISSN 1095-5054.
The most fundamental heuristic is trial and error, which can be used in everything from matching nuts and bolts to finding the values of variables in algebra problems. In mathematics, some common heuristics involve the use of visual representations, additional assumptions, forward/backward reasoning and simplification. Here are a few commonly used heuristics from George Pólya's 1945 book, How to Solve It:[6].mw-parser-output .templatequote{overflow:hidden;margin:1em 0;padding:0 40px}.mw-parser-output .templatequote .templatequotecite{line-height:1.5em;text-align:left;padding-left:1.6em;margin-top:0}
Decision Making under Uncertainty: Cognitive Decision Research, Social Interaction, Development and Epistemology
In 2002, Daniel Kahneman and Shane Frederick proposed that cognitive heuristics work by a process called attribute substitution, which happens without conscious awareness.[18] According to this theory, when somebody makes a judgement (of a "target attribute") that is computationally complex, a more easily calculated "heuristic attribute" is substituted. In effect, a cognitively difficult problem is dealt with by answering a rather simpler problem, without being aware of this happening.[18] This theory explains cases where judgements fail to show regression toward the mean.[19] Heuristics can be considered to reduce the complexity of clinical judgments in health care.[20]
^ Pólya, George (1945) How to Solve It: A New Aspect of Mathematical Method, Princeton, NJ: Princeton University Press. ISBN 0-691-02356-5 ISBN 0-691-08097-6
Gigerenzer, Gerd; Brighton, Henry (2009). "Homo Heuristicus: Why Biased Minds Make Better Inferences". Topics in Cognitive Science. 1 (1): 107–143. doi:10.1111/j.1756-8765.2008.01006.x. hdl:11858/00-001M-0000-0024-F678-0. ISSN 1756-8765. PMID 25164802.
Gigerenzer, Gerd; Todd, Peter M.; and the ABC Research Group (1999). Simple Heuristics That Make Us Smart. Oxford, UK: Oxford University Press. ISBN 978-0-19512-156-8.
Braun, T.D.; Siegal, H.J.; Beck, N.; Boloni, L.L.; Maheswaran, M.; Reuther, A.I.; Robertson, J.P.; Theys, M.D.; Bin Yao; Hensgen, D.; Freund, R.F. (1999). "A comparison study of static mapping heuristics for a class of meta-tasks on heterogeneous computing systems". Proceedings. Eighth Heterogeneous Computing Workshop (HCW'99). IEEE Comput. Soc: 15–29. doi:10.1109/hcw.1999.765093. hdl:10945/35227. ISBN 0-7695-0107-9. S2CID 2860157.
"How to Make Cognitive Illusions Disappear: Beyond "Heuristics and Biases""
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Myers, David G. (2010). Social psychology (Tenth ed.). New York, NY: McGraw-Hill. p. 94. ISBN 978-0-07337-066-8. OCLC 667213323.
Gigerenzer, Gerd; Brighton, Henry (2009). "Homo heuristicus: why biased minds make better inferences". Topics in Cognitive Science. 1 (1): 107–143. doi:10.1111/j.1756-8765.2008.01006.x. hdl:11858/00-001M-0000-0024-F678-0. ISSN 1756-8765. PMID 25164802.
^ Emiliano, Ippoliti (2015). Heuristic Reasoning: Studies in Applied Philosophy, Epistemology and Rational Ethics. Switzerland: Springer International Publishing. pp. 1–2. ISBN 978-3-319-09159-4.
Gigerenzer, Gerd; Hertwig, Ralph; Pachur, Thorsten (15 April 2011). Heuristics: The Foundations of Adaptive Behavior. Oxford University Press. doi:10.1093/acprof:oso/9780199744282.001.0001. hdl:11858/00-001M-0000-0024-F172-8. ISBN 978-0-19989-472-7.
Scholz, R. W. (1983-11-01). Decision Making under Uncertainty: Cognitive Decision Research, Social Interaction, Development and Epistemology. Elsevier. ISBN 978-0-08-086670-3.
Frigg, Roman; Hartmann, Stephan (2006). "Models in Science". Stanford Encyclopedia of Philosophy. ISSN 1095-5054.
^ Kahneman, Daniel (December 2003). "Maps of Bounded Rationality: Psychology for Behavioral Economics" (PDF). American Economic Review. 93 (5): 1449–1475. CiteSeerX 10.1.1.194.6554. doi:10.1257/000282803322655392. ISSN 0002-8282. Archived from the original (PDF) on 19 February 2018.
^ Sunstein, Cass (2005). "Moral Heuristics". The Behavioral and Brain Sciences. 28 (4): 531–542. doi:10.1017/S0140525X05000099. PMID 16209802. S2CID 231738548.
^ Gigerenzer, Gerd; Engel, Christoph, eds. (2007). Heuristics and the Law. Cambridge, MA: MIT Press. ISBN 978-0-262-07275-5.
Stereotyping is a type of heuristic that people use to form opinions or make judgements about things they have never seen or experienced.[37] They work as a mental shortcut to assess everything from the social status of a person (based on their actions),[2] to whether a plant is a tree based on the assumption that it is tall, has a trunk and has leaves (even though the person making the evaluation might never have seen that particular type of tree before).
Kahneman, Daniel; Slovic, Paul; Tversky, Amos, eds. (30 April 1982). Judgment Under Uncertainty. Cambridge, UK: Cambridge University Press. doi:10.1017/cbo9780511809477. ISBN 978-0-52128-414-1.
Emiliano, Ippoliti (2015). Heuristic Reasoning: Studies in Applied Philosophy, Epistemology and Rational Ethics. Switzerland: Springer International Publishing. pp. 1–2. ISBN 978-3-319-09159-4.
A number of complexity classes are defined using interactive proof systems. Interactive proofs generalize the proofs definition of the complexity class NP and yield insights into cryptography, approximation algorithms, and formal verification.
a string w{\displaystyle w} not in L{\displaystyle L} implies that Pr[M rejects w]≥1−ϵ{\displaystyle {\text{Pr}}[M{\text{ rejects }}w]\geq 1-\epsilon }
While it is possible to define logarithmic time complexity classes, these are extremely narrow classes as sublinear times do not even enable a Turing machine to read the entire input (because log⁡n<n{\displaystyle \log n<n}).[a][8] However, there are a meaningful number of problems that can be solved in logarithmic space. The definitions of these classes require a two-tape Turing machine so that it is possible for the machine to store the entire input (it can be shown that in terms of computability the two-tape Turing machine is equivalent to the single-tape Turing machine).[9] In the two-tape Turing machine model, one tape is the input tape, which is read-only. The other is the work tape, which allows both reading and writing and is the tape on which the Turing machine performs computations. The space complexity of the Turing machine is measured as the number of cells that are used on the work tape.
3Properties of complexity classes											Toggle Properties of complexity classes subsection																					3.1Closure																											3.2Reductions																								3.2.1Hardness																											3.2.2Completeness
#P (pronounced "sharp P") is an important class of counting problems that can be thought of as the counting version of NP.[21] The connection to NP arises from the fact that the number of solutions to a problem equals the number of accepting branches in a nondeterministic Turing machine's computation tree. #P is thus formally defined as follows:
DTIME(f(n))⊊DTIME(f(n)⋅log2⁡(f(n))){\displaystyle {\mathsf {DTIME}}{\big (}f(n){\big )}\subsetneq {\mathsf {DTIME}}{\big (}f(n)\cdot \log ^{2}(f(n)){\big )}}
The most commonly analyzed problems in theoretical computer science are decision problems—the kinds of problems that can be posed as yes-no questions. The primality example above, for instance, is an example of a decision problem as it can be represented by the yes-no question "is the natural number n{\displaystyle n} prime". In terms of the theory of computation, a decision problem is represented as the set of input strings that a computer running a correct algorithm would answer "yes" to. In the primality example, PRIME{\displaystyle {\texttt {PRIME}}} is the set of strings representing natural numbers that, when input into a computer running an algorithm that correctly tests for primality, the algorithm answers "yes, this number is prime". This "yes-no" format is often equivalently stated as "accept-reject"; that is, an algorithm "accepts" an input string if the answer to the decision problem is "yes" and "rejects" if the answer is "no".
A number of classes are defined using Boolean circuits, including the classes P/poly and its subclasses NC and AC
Pr[V accepts w after interacting with P]≤13{\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\leq {\tfrac {1}{3}}}
Complexity classes are often defined using granular sets of complexity classes called DTIME and NTIME (for time complexity) and DSPACE and NSPACE (for space complexity). Using big O notation, they are defined as follows:
Loosening the error requirements further to allow for two-sided error yields the class BPP (bounded-error probabilistic polynomial time), the class of problems solvable in polynomial time by a probabilistic Turing machine with error probability less than 1/3 (for both strings in the language and not in the language). BPP is the most practically relevant of the probabilistic complexity classes—problems in BPP have efficient randomized algorithms that can be run quickly on real computers. BPP is also at the center of the important unsolved problem in computer science over whether P=BPP, which if true would mean that randomness does not increase the computational power of computers, i.e. any probabilistic Turing machine could be simulated by a deterministic Turing machine with at most polynomial slowdown.
A Turing machine is a mathematical model of a general computing machine. It is the most commonly used model in complexity theory, owing in large part to the fact that it is believed to be as powerful as any other model of computation and is easy to analyze mathematically. Importantly, it is believed that if there exists an algorithm that solves a particular problem then there also exists a Turing machine that solves that same problem (this is known as the Church–Turing thesis); this means that it is believed that every algorithm can be represented as a Turing machine.
Goldreich, Oded (2006). "On Promise Problems: A Survey" (PDF).In Goldreich, Oded; Rosenberg, Arnold L.; Selman, Alen L. (eds.). Theoretical Computer Science. Lecture Notes in Computer Science, vol 3895 (PDF). Lecture Notes in Computer Science. Vol. 3895. Springer. pp. 254–290. doi:10.1007/11685654_12. ISBN 978-3-540-32881-0. Archived (PDF) from the original on May 6, 2021.
In computational complexity theory, a complexity class is a set of computational problems of related resource-based complexity. The two most commonly analyzed resources are time and memory.
^ Note that while a logarithmic runtime of clog⁡n{\displaystyle c\log n}, i.e. log⁡n{\displaystyle \log n} multiplied by a constant c{\displaystyle c}, allows a Turning machine to read inputs of size nclog⁡n{\displaystyle n>c\log n}.
A probabilistic Turing machine is similar to a deterministic Turing machine, except rather than following a single transition function (a set of rules for how to proceed at each step of the computation) it probabilistically selects between multiple transition functions at each step. The standard definition of a probabilistic Turing machine specifies two transition functions, so that the selection of transition function at each step resembles a coin flip. The randomness introduced at each step of the computation introduces the potential for error; that is, strings that the Turing machine is meant to accept may on some occasions be rejected and strings that the Turing machine is meant to reject may on some occasions be accepted. As a result, the complexity classes based on the probabilistic Turing machine are defined in large part around the amount of error that is allowed. Formally, they are defined using an error probability ϵ{\displaystyle \epsilon }. A probabilistic Turing machine M{\displaystyle M} is said to recognize a language L{\displaystyle L} with error probability ϵ{\displaystyle \epsilon } if:
To make concrete the notion of a "computer", in theoretical computer science problems are analyzed in the context of a computational model. Computational models make exact the notions of computational resources like "time" and "memory". In computational complexity theory, complexity classes deal with the inherent resource requirements of problems and not the resource requirements that depend upon how a physical computer is constructed. For example, in the real world different computers may require different amounts of time and memory to solve the same problem because of the way that they have been engineered. By providing an abstract mathematical representations of computers, computational models abstract away superfluous complexities of the real world (like differences in processor speed) that obstruct an understanding of fundamental principles.
Important randomized space complexity classes include BPL, RL, and RLP.
Mechanically, a Turing machine (TM) manipulates symbols (generally restricted to the bits 0 and 1 to provide an intuitive connection to real-life computers) contained on an infinitely long strip of tape. The TM can read and write, one at a time, using a tape head. Operation is fully determined by a finite set of elementary instructions such as "in state 42, if the symbol seen is 0, write a 1; if the symbol seen is 1, change into state 17; in state 17, if the symbol seen is 0, write a 1 and change to state 6". The Turing machine starts with only the input string on its tape and blanks everywhere else. The TM accepts the input if it enters a designated accept state and rejects the input if it enters a reject state. The deterministic Turing machine (DTM) is the most basic type of Turing machine. It uses a fixed set of rules to determine its future actions (which is why it is called "deterministic").
The space complexity class DSPACE(s(n)){\displaystyle {\mathsf {DSPACE}}(s(n))} is the set of all problems that are decided by an O(s(n)){\displaystyle O(s(n))} space deterministic Turing machine.
Classes of decision problems—that is, classes of problems defined as formal languages—thus translate naturally to promise problems, where a language L{\displaystyle L} in the class is simply L=ΠACCEPT{\displaystyle L=\Pi _{\text{ACCEPT}}} and ΠREJECT{\displaystyle \Pi _{\text{REJECT}}} is implicitly {0,1}∗/ΠACCEPT{\displaystyle \{0,1\}^{*}/\Pi _{\text{ACCEPT}}}.
Counting problems are a subset of a broader class of problems called function problems. A function problem is a type of problem in which the values of a function f:A→B{\displaystyle f:A\to B} are computed. Formally, a function problem f{\displaystyle f} is defined as a relation R{\displaystyle R} over strings of an arbitrary alphabet Σ{\displaystyle \Sigma }:
Theoretical Computer Science. Lecture Notes in Computer Science, vol 3895
ΠACCEPT⊆{0,1}∗{\displaystyle \Pi _{\text{ACCEPT}}\subseteq \{0,1\}^{*}} is the set of all inputs that are accepted.
The complexity classes PSPACE and NPSPACE are the space analogues toP andNP. That is, PSPACE is the class of problems solvable in polynomial space by a deterministic Turing machine and NPSPACE is the class of problems solvable in polynomial space by a nondeterministic Turing machine. More formally,
Note that reductions can be defined in many different ways. Common reductions are Cook reductions, Karp reductions and Levin reductions, and can vary based on resource bounds, such as polynomial-time reductions and log-space reductions.
Formulating many basic complexity classes like P as promise problems provides little additional insight into their nature. However, there are some complexity classes for which formulating them as promise problems have been useful to computer scientists. Promise problems have, for instance, played a key role in the study of SZK (statistical zero-knowledge).[27]
An important feature of IP is that it equals PSPACE. In other words, any problem that can be solved by a polynomial-time interactive proof system can also be solved by a deterministic Turing machine with polynomial space resources, and vice versa.
P is often said to be the class of problems that can be solved "quickly" or "efficiently" by a deterministic computer, since the time complexity of solving a problem in P increases relatively slowly with the input size.
It is also possible to use the Blum axioms to define complexity classes without referring to a concrete computational model, but this approach is less frequently used in complexity theory.
The time complexity class NTIME(t(n)){\displaystyle {\mathsf {NTIME}}(t(n))} is the set of all problems that are decided by an O(t(n)){\displaystyle O(t(n))} time nondeterministic Turing machine.
A number of classes are defined using probabilistic Turing machines, including the classes BPP, PP, RP, and ZPP
The space complexity of an algorithm with respect to the Turing machine model is the number of cells on the Turing machine's tape that are required to run an algorithm on a given input size. Formally, the space complexity of an algorithm implemented with a Turing machine M{\displaystyle M} is defined as the function sM:N→N{\displaystyle s_{M}:\mathbb {N} \to \mathbb {N} }, where sM(n){\displaystyle s_{M}(n)} is the maximum number of cells that M{\displaystyle M} uses on any input of length n{\displaystyle n}.
The time complexity of an algorithm with respect to the Turing machine model is the number of steps it takes for a Turing machine to run an algorithm on a given input size. Formally, the time complexity for an algorithm implemented with a Turing machine M{\displaystyle M} is defined as the function tM:N→N{\displaystyle t_{M}:\mathbb {N} \to \mathbb {N} }, where tM(n){\displaystyle t_{M}(n)} is the maximum number of steps that M{\displaystyle M} takes on any input of length n{\displaystyle n}.
The most general complexity class arising out of this characterization is the class IP (interactive polynomial time), which is the class of all problems solvable by an interactive proof system (P,V){\displaystyle (P,V)}, where V{\displaystyle V} is probabilistic polynomial-time and the proof system satisfies two properties: for a language L∈IP{\displaystyle L\in {\mathsf {IP}}}
Savitch's theorem establishes the relationship between deterministic and nondetermistic space resources. It shows that if a nondeterministic Turing machine can solve a problem using f(n){\displaystyle f(n)} space, then a deterministic Turing machine can solve the same problem in f(n)2{\displaystyle f(n)^{2}} space, i.e. in the square of the space. Formally, Savitch's theorem states that for any f(n)>n{\displaystyle f(n)>n},[13]
5Other models of computation											Toggle Other models of computation subsection																					5.1Randomized computation																								5.1.1Important complexity classes																														5.2Interactive proof systems																								5.2.1Important complexity classes																														5.3Boolean circuits																								5.3.1Important complexity classes																														5.4Quantum computation
EXPTIME is a strict superset of P and NEXPTIME is a strict superset of NP. It is further the case that EXPTIME⊆{\displaystyle \subseteq }NEXPTIME. It is not known whether this is proper, but if P=NP then EXPTIME must equal NEXPTIME.
The classes BQP and QMA, which are of key importance in quantum information science, are defined using quantum Turing machines.
Pr[V accepts w after interacting with P]≥23{\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\geq {\tfrac {2}{3}}}
Of particular importance is the class of NP-complete problems—the most difficult problems in NP. Because all problems in NP can be polynomial-time reduced to NP-complete problems, finding an NP-complete problem that can be solved in polynomial time would mean that P = NP.
The strictest class is ZPP (zero-error probabilistic polynomial time), the class of problems solvable in polynomial time by a probabilistic Turing machine with error probability 0. Intuitively, this is the strictest class of probabilistic problems because it demands no error whatsoever.
While some problems cannot easily be expressed as decision problems, they nonetheless encompass a broad range of computational problems.[1] Other types of problems that certain complexity classes are defined in terms of include function problems (e.g. FP), counting problems (e.g. #P), optimization problems, and promise problems (see section "Other types of problems").
While there might seem to be an obvious difference between the class of problems that are efficiently solvable and the class of problems whose solutions are merely efficiently checkable, P and NP are actually at the center of one of the most famous unsolved problems in computer science: the P versus NP problem. While it is known that P⊆{\displaystyle \subseteq }NP (intuitively, deterministic Turing machines are just a subclass of nondeterministic Turing machines that don't make use of their nondeterminism; or under the verifier definition, P is the class of problems whose polynomial time verifiers need only receive the empty string as their certificate), it is not known whether NP is strictly larger than P. If P=NP, then it follows that nondeterminism provides no additional computational power over determinism with regards to the ability to quickly find a solution to a problem; that is, being able to explore all possible branches of computation provides at most a polynomial speedup over being able to explore only a single branch. Furthermore, it would follow that if there exists a proof for a problem instance and that proof can be quickly be checked for correctness (that is, if the problem is in NP), then there also exists an algorithm that can quickly construct that proof (that is, the problem is in P).[5] However, the overwhelming majority of computer scientists believe that P≠{\displaystyle \neq }NP,[6] and most cryptographic schemes employed today rely on the assumption that P≠{\displaystyle \neq }NP.[7]
Thus, whereas decision problems are represented mathematically as formal languages, counting problems are represented mathematically as functions: a counting problem is formalized as the function f:{0,1}∗→N{\displaystyle f:\{0,1\}^{*}\to \mathbb {N} } such that for every input w∈{0,1}∗{\displaystyle w\in \{0,1\}^{*}}, f(w){\displaystyle f(w)} is the number of solutions. For example, in the #CYCLE{\displaystyle \#{\texttt {CYCLE}}} problem, the input is a graph G∈{0,1}∗{\displaystyle G\in \{0,1\}^{*}} (a graph represented as a string of bits) and f(G){\displaystyle f(G)} is the number of simple cycles in G{\displaystyle G}.
Complexity classes are sets of related computational problems. They are defined in terms of the computational difficulty of solving the problems contained within them with respect to particular computational resources like time or memory. More formally, the definition of a complexity class consists of three things: a type of computational problem, a model of computation, and a bounded computational resource. In particular, most complexity classes consist of decision problems that can be solved by a Turing machine with bounded time or space resources. For example, the complexity class P is defined as the set of decision problems that can be solved by a deterministic Turing machine in polynomial time.
Michael Garey, and David S. Johnson: Computers and Intractability: A Guide to the Theory of NP-Completeness. New York: W. H. Freeman & Co., 1979.The standard reference on NP-Complete problems - an important category of problems whose solutions appear to require an impractically long time to compute.
Complexity classes have a variety of closure properties. For example, decision classes may be closed under negation, disjunction, conjunction, or even under all Boolean operations. Moreover, they might also be closed under a variety of quantification schemes. P, for instance, is closed under all Boolean operations, and under quantification over polynomially sized domains. Closure properties can be helpful in separating classes—one possible route to separating two complexity classes is to find some closure property possessed by one class but not by the other.
ΠREJECT⊆{0,1}∗{\displaystyle \Pi _{\text{REJECT}}\subseteq \{0,1\}^{*}} is the set of all inputs that are rejected.
It is known that L⊆NL⊆P{\displaystyle {\mathsf {L}}\subseteq {\mathsf {NL}}\subseteq {\mathsf {P}}}. However, it is not known whether any of these relationships is proper.
Each class X that is not closed under negation has a complement class co-X, which consists of the complements of the languages contained in X (i.e. co-X={L|L¯∈{\displaystyle \{L|{\overline {L}}\in } X }{\displaystyle \}}). co-NP, for instance, is one important complement complexity class, and sits at the center of the unsolved problem over whether co-NP=NP.
Turing machines enable intuitive notions of "time" and "space". The time complexity of a TM on a particular input is the number of elementary steps that the Turing machine takes to reach either an accept or reject state. The space complexity is the number of cells on its tape that it uses to reach either an accept or reject state.
Arora, Sanjeev; Barak, Boaz (2009). Computational Complexity: A Modern Approach. Cambridge University Press. Draft. Archived from the original on February 23, 2022. ISBN 978-0-521-42426-4.
6Other types of problems											Toggle Other types of problems subsection																					6.1Counting problems																								6.1.1Important complexity classes																														6.2Function problems																								6.2.1Important complexity classes																														6.3Promise problems																								6.3.1Relation to complexity classes
The complexity classes EXPSPACE and NEXPSPACE are the space analogues to EXPTIME and NEXPTIME. That is, EXPSPACE is the class of problems solvable in exponential space by a deterministic Turing machine and NEXPSPACE is the class of problems solvable in exponential space by a nondeterministic Turing machine. Or more formally,
Other complexity classes defined using interactive proof systems include MIP (multiprover interactive polynomial time) and QIP (quantum interactive polynomial time).
It turns out that NP captures the full power of interactive proof systems with deterministic (polynomial-time) verifiers because it can be shown that for any proof system with a deterministic verifier it is never necessary to need more than a single round of messaging between the prover and the verifier. Interactive proof systems that provide greater computational power over standard complexity classes thus require probabilistic verifiers, which means that the verifier's questions to the prover are computed using probabilistic algorithms. As noted in the section above on randomized computation, probabilistic algorithms introduce error into the system, so complexity classes based on probabilistic proof systems are defined in terms of an error probability ϵ{\displaystyle \epsilon }.
The fundamental randomized time complexity classes are ZPP, RP, co-RP, BPP, and PP.
Gasarch, William I. (2019). "Guest Column: The Third P =? NP Poll" (PDF). University of Maryland. Archived (PDF) from the original on November 2, 2021.
These relationships answer fundamental questions about the power of nondeterminism compared to determinism. Specifically, Savitch's theorem shows that any problem that a nondeterministic Turing machine can solve in polynomial space, a deterministic Turing machine can also solve in polynomial space. Similarly, any problem that a nondeterministic Turing machine can solve in exponential space, a deterministic Turing machine can also solve in exponential space.
An important characteristic of the class NP is that it can be equivalently defined as the class of problems whose solutions are verifiable by a deterministic Turing machine in polynomial time. That is, a language is in NP if there exists a deterministic polynomial time Turing machine, referred to as the verifier, that takes as input a string w{\displaystyle w} and a polynomial-size certificate string c{\displaystyle c}, and accepts w{\displaystyle w} if w{\displaystyle w} is in the language and rejects w{\displaystyle w} if w{\displaystyle w} is not in the language. Intuitively, the certificate acts as a proof that the input w{\displaystyle w} is in the language. Formally:[4]
Barak, Boaz (Spring 2006). "Complexity of counting" (PDF). Computer Science 522: Computational Complexity. Princeton University. Archived from the original on April 3, 2021.
Note that the study of complexity classes is intended primarily to understand the inherent complexity required to solve computational problems. Complexity theorists are thus generally concerned with finding the smallest complexity class that a problem falls into and are therefore concerned with identifying which class a computational problem falls into using the most efficient algorithm. There may be an algorithm, for instance, that solves a particular problem in exponential time, but if the most efficient algorithm for solving this problem runs in polynomial time then the inherent time complexity of that problem is better described as polynomial.
Closure properties are one of the key reasons many complexity classes are defined in the way that they are.[10] Take, for example, a problem that can be solved in O(n){\displaystyle O(n)} time (that is, in linear time) and one that can be solved in, at best, O(n1000){\displaystyle O(n^{1000})} time. Both of these problems are in P, yet the runtime of the second grows considerably faster than the runtime of the first as the input size increases. One might ask whether it would be better to define the class of "efficiently solvable" problems using some smaller polynomial bound, like O(n3){\displaystyle O(n^{3})}, rather than all polynomials, which allows for such large discrepancies. It turns out, however, that the set of all polynomials is the smallest class of functions containing the linear functions that is also closed under addition, multiplication, and composition (for instance, O(n3)∘O(n2)=O(n6){\displaystyle O(n^{3})\circ O(n^{2})=O(n^{6})}, which is a polynomial but O(n6)>O(n3){\displaystyle O(n^{6})>O(n^{3})}).[10] Since we would like composing one efficient algorithm with another efficient algorithm to still be considered efficient, the polynomials are the smallest class that ensures composition of "efficient algorithms".[11] (Note that the definition of P is also useful because, empirically, almost all problems in P that are practically useful do in fact have low order polynomial runtimes, and almost all problems outside of P that are practically useful do not have any known algorithms with small exponential runtimes, i.e. with O(cn){\displaystyle O(c^{n})} runtimes where c{\displaystyle c} is close to 1.[12])
The class NP is a simple proof system in which the verifier is restricted to being a deterministic polynomial-time Turing machine and the procedure is restricted to one round (that is, the prover sends only a single, full proof—typically referred to as the certificate—to the verifier). Put another way, in the definition of the class NP (the set of decision problems for which the problem instances, when the answer is "YES", have proofs verifiable in polynomial time by a deterministic Turing machine) is a proof system in which the proof is constructed by an unmentioned prover and the deterministic Turing machine is the verifier. For this reason, NP can also be called dIP (deterministic interactive proof), though it is rarely referred to as such.
A modification of the protocol for IP produces another important complexity class: AM (Arthur–Merlin protocol). In the definition of interactive proof systems used by IP, the prover was not able to see the coins utilized by the verifier in its probabilistic computation—it was only able to see the messages that the verifier produced with these coins. For this reason, the coins are called private random coins. The interactive proof system can be constrained so that the coins used by the verifier are public random coins; that is, the prover is able to see the coins. Formally, AM is defined as the class of languages with an interactive proof in which the verifier sends a random string to the prover, the prover responds with a message, and the verifier either accepts or rejects by applying a deterministic polynomial-time function to the message from the prover. AM can be generalized to AM[k], where k is the number of messages exchanged (so in the generalized form the standard AM defined above is AM[2]). However, it is the case that for all k≥2{\displaystyle k\geq 2}, AM[k]=AM[2]. It is also the case that AM[k]⊆IP[k]{\displaystyle {\mathsf {AM}}[k]\subseteq {\mathsf {IP}}[k]}.
4Relationships between complexity classes											Toggle Relationships between complexity classes subsection																					4.1Savitch's theorem																											4.2Hierarchy theorems
PRIME={n∈N|n is prime}{\displaystyle {\texttt {PRIME}}=\{n\in \mathbb {N} |n{\text{ is prime}}\}}
2.3Space complexity classes																								2.3.1L and NL																											2.3.2PSPACE and NPSPACE																											2.3.3EXPSPACE and NEXPSPACE
The time complexity of an NTM is the maximum number of steps that the NTM uses on any branch of its computation.[3] Similarly, the space complexity of an NTM is the maximum number of cells that the NTM uses on any branch of its computation.
An alternative model of computation to the Turing machine is the Boolean circuit, a simplified model of the digital circuits used in modern computers. Not only does this model provide an intuitive connection between computation in theory and computation in practice, but it is also a natural model for non-uniform computation (computation in which different input sizes within the same problem use different algorithms).
A number of classes are defined using quantum Turing machines, including the classes BQP and QMA
Many complexity classes are defined using the concept of a reduction. A reduction is a transformation of one problem into another problem, i.e. a reduction takes inputs from one problem and transforms them into inputs of another problem. For instance, you can reduce ordinary base-10 addition x+y{\displaystyle x+y} to base-2 addition by transforming x{\displaystyle x} and y{\displaystyle y} to their base-2 notation (e.g. 5+7 becomes 101+111). Formally, a problem X{\displaystyle X} reduces to a problem Y{\displaystyle Y} if there exists a function f{\displaystyle f} such that for every x∈Σ∗{\displaystyle x\in \Sigma ^{*}}, x∈X{\displaystyle x\in X} if and only if f(x)∈Y{\displaystyle f(x)\in Y}.
1Background											Toggle Background subsection																					1.1Computational problems																								1.1.1Decision problems																														1.2Computational models																								1.2.1Deterministic Turing machines																											1.2.2Nondeterministic Turing machines																														1.3Resource bounds																								1.3.1Time bounds																											1.3.2Space bounds
Any particular circuit has a fixed number of input vertices, so it can only act on inputs of that size. Languages (the formal representations of decision problems), however, contain strings of differing lengths, so languages cannot be fully captured by a single circuit (this contrasts with the Turing machine model, in which a language is fully described by a single Turing machine that can act on any input size). A language is thus represented by a circuit family. A circuit family is an infinite list of circuits (C0,C1,C2,...){\displaystyle (C_{0},C_{1},C_{2},...)}, where Cn{\displaystyle C_{n}} is a circuit with n{\displaystyle n} input variables. A circuit family is said to decide a language L{\displaystyle L} if, for every string w{\displaystyle w}, w{\displaystyle w} is in the language L{\displaystyle L} if and only if Cn(w)=1{\displaystyle C_{n}(w)=1}, where n{\displaystyle n} is the length of w{\displaystyle w}. In other words, a string w{\displaystyle w} of size n{\displaystyle n} is in the language represented by the circuit family (C0,C1,C2,...){\displaystyle (C_{0},C_{1},C_{2},...)} if the circuit Cn{\displaystyle C_{n}} (the circuit with the same number of input vertices as the number of bits in w{\displaystyle w}) evaluates to 1 when w{\displaystyle w} is its input.
Sipser, Michael (2006). Introduction to the Theory of Computation (PDF) (2nd ed.). USA: Thomson Course Technology. ISBN 0-534-95097-3. Archived from the original (PDF) on February 7, 2022.
Interactive proof systems are abstract machines that model computation as the exchange of messages between two parties: a prover P{\displaystyle P} and a verifier V{\displaystyle V}. The parties interact by exchanging messages, and an input string is accepted by the system if the verifier decides to accept the input on the basis of the messages it has received from the prover. The prover P{\displaystyle P} has unlimited computational power while the verifier has bounded computational power (the standard definition of interactive proof systems defines the verifier to be polynomially-time bounded). The prover, however, is untrustworthy (this prevents all languages from being trivially recognized by the proof system by having the computationally unbounded prover solve for whether a string is in a language and then sending a trustworthy "YES" or "NO" to the verifier), so the verifier must conduct an "interrogation" of the prover by "asking it" successive rounds of questions, accepting only if it develops a high degree of confidence that the string is in the language.[14]
Important corollaries of Savitch's theorem are that PSPACE = NPSPACE (since the square of a polynomial is still a polynomial) and EXPSPACE = NEXPSPACE (since the square of an exponential is still an exponential).
The time complexity class DTIME(t(n)){\displaystyle {\mathsf {DTIME}}(t(n))} is the set of all problems that are decided by an O(t(n)){\displaystyle O(t(n))} time deterministic Turing machine.
While it is not known whether P=NP, Savitch's theoremfamously showed that PSPACE=NPSPACE. It is also known that P⊆{\displaystyle \subseteq }PSPACE, which follows intuitively from the fact that, since writing to a cell on a Turing machine's tape is defined as taking one unit of time, a Turing machine operating in polynomial time can only write to polynomially many cells. It is suspected that P is strictly smaller than PSPACE, but this has not been proven.
While deterministic and non-deterministic Turing machines are the most commonly used models of computation, many complexity classes are defined in terms of other computational models. In particular,
Savitch's theorem showed that EXPSPACE=NEXPSPACE. This class is extremely broad: it is known to be a strict superset of PSPACE, NP, and P, and is believed to be a strict superset of EXPTIME.
Note that while a logarithmic runtime of clog⁡n{\displaystyle c\log n}, i.e. log⁡n{\displaystyle \log n} multiplied by a constant c{\displaystyle c}, allows a Turning machine to read inputs of size nclog⁡n{\displaystyle n>c\log n}.
The most commonly used computational model is the Turing machine. While other models exist and many complexity classes are defined in terms of them (see section "Other models of computation"), the Turing machine is used to define most basic complexity classes. With the Turing machine, instead of using standard units of time like the second (which make it impossible to disentangle running time from the speed of physical hardware) and standard units of memory like bytes, the notion of time is abstracted as the number of elementary steps that a Turing machine takes to solve a problem and the notion of memory is abstracted as the number of cells that are used on the machine's tape. These are explained in greater detail below.
An important function complexity class is FP, the class of efficiently solvable functions.[22] More specifically, FP is the set of function problems that can be solved by a deterministic Turing machine in polynomial time.[22] FP can be thought of as the function problem equivalent of P. Importantly, FP provides some insight into both counting problems and P versus NP. If #P=FP, then the functions that determine the number of certificates for problems in NP are efficiently solvable. And since computing the number of certificates is at least as hard as determining whether a certificate exists, it must follow that if #P=FP then P=NP (it is not known whether this holds in the reverse, i.e. whether P=NP implies #P=FP).[22]
In general, a complexity class is defined in terms of a type of computational problem, a model of computation, and a bounded resource like time or memory. In particular, most complexity classes consist of decision problems that are solvable with a Turing machine, and are differentiated by their time or space (memory) requirements. For instance, the class P is the set of decision problems solvable by a deterministic Turing machine in polynomial time. There are, however, many complexity classes defined in terms of other types of problems (e.g. counting problems and function problems) and using other models of computation (e.g. probabilistic Turing machines, interactive proof systems, Boolean circuits, and quantum computers).
(Soundness) a string w{\displaystyle w} not in L{\displaystyle L} implies Pr[V accepts w after interacting with P]≤13{\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\leq {\tfrac {1}{3}}}
An algorithm solves f{\displaystyle f} if for every input x{\displaystyle x} such that there exists a y{\displaystyle y} satisfying (x,y)∈R{\displaystyle (x,y)\in R}, the algorithm produces one such y{\displaystyle y}. This is just another way of saying that f{\displaystyle f} is a function and the algorithm solves f(x){\displaystyle f(x)} for all x∈Σ∗{\displaystyle x\in \Sigma ^{*}}.
Rich, Elaine (2008). Automata, Computability and Complexity: Theory and Applications (PDF). Prentice Hall. ISBN 978-0132288064. Archived (PDF) from the original on January 21, 2022.
Arora, Sanjeev (Spring 2003). "Complexity classes having to do with counting". Computer Science 522: Computational Complexity Theory. Princeton University. Archived from the original on May 21, 2021.
(Completeness) a string w{\displaystyle w} in L{\displaystyle L} implies Pr[V accepts w after interacting with P]≥23{\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\geq {\tfrac {2}{3}}}
A computational problem can then be defined in terms of a Turing machine as the set of input strings that a particular Turing machine accepts. For example, the primality problem PRIME{\displaystyle {\texttt {PRIME}}} from above is the set of strings (representing natural numbers) that a Turing machine running an algorithm that correctly tests for primality accepts. A Turing machine is said to recognize a language (recall that "problem" and "language" are largely synonymous in computability and complexity theory) if it accepts all inputs that are in the language and is said to decide a language if it additionally rejects all inputs that are not in the language (certain inputs may cause a Turing machine to run forever, so decidability places the additional constraint over recognizability that the Turing machine must halt on all inputs). A Turing machine that "solves" a problem is generally meant to mean one that decides the language.
While most complexity classes studied by computer scientists are sets of decision problems, there are also a number of complexity classes defined in terms of other types of problems. In particular, there are complexity classes consisting of counting problems, function problems, and promise problems. These are explained in greater detail below.
Intuitively, a computational problem is just a question that can be solved by an algorithm. For example, "is the natural number n{\displaystyle n} prime?" is a computational problem. A computational problem is mathematically represented as the set of answers to the problem. In the primality example, the problem (call it PRIME{\displaystyle {\texttt {PRIME}}}) is represented by the set of all natural numbers that are prime: PRIME={n∈N|n is prime}{\displaystyle {\texttt {PRIME}}=\{n\in \mathbb {N} |n{\text{ is prime}}\}}. In the theory of computation, these answers are represented as strings; for example, in the primality example the natural numbers could be represented as strings of bits that represent binary numbers. For this reason, computational problems are often synonymously referred to as languages, since strings of bits represent formal languages (a concept borrowed from linguistics); for example, saying that the PRIME{\displaystyle {\texttt {PRIME}}} problem is in the complexity class NP is equivalent to saying that the language PRIME{\displaystyle {\texttt {PRIME}}} is in NP.
The space complexity class NSPACE(s(n)){\displaystyle {\mathsf {NSPACE}}(s(n))} is the set of all problems that are decided by an O(s(n)){\displaystyle O(s(n))} space nondeterministic Turing machine.
A counting problem asks not only whether a solution exists (as with a decision problem), but asks how many solutions exist.[17] For example, the decision problem CYCLE{\displaystyle {\texttt {CYCLE}}} asks whether a particular graph G{\displaystyle G} has a simple cycle (the answer is a simple yes/no); the corresponding counting problem #CYCLE{\displaystyle \#{\texttt {CYCLE}}} (pronounced "sharp cycle") asks how many simple cycles G{\displaystyle G} has.[18] The output to a counting problem is thus a number, in contrast to the output for a decision problem, which is a simple yes/no (or accept/reject, 0/1, or other equivalent scheme).[19]
This page was last edited on 15 November 2022, at 14:16 (UTC).
A number of important complexity classes are defined using the probabilistic Turing machine, a variant of the Turing machine that can toss random coins. These classes help to better describe the complexity of randomized algorithms.
The input to an algorithm M{\displaystyle M} for a promise problem (ΠACCEPT,ΠREJECT){\displaystyle (\Pi _{\text{ACCEPT}},\Pi _{\text{REJECT}})} is thus ΠACCEPT∪ΠREJECT{\displaystyle \Pi _{\text{ACCEPT}}\cup \Pi _{\text{REJECT}}}, which is called the promise. Strings in ΠACCEPT∪ΠREJECT{\displaystyle \Pi _{\text{ACCEPT}}\cup \Pi _{\text{REJECT}}} are said to satisfy the promise.[24] By definition, ΠACCEPT{\displaystyle \Pi _{\text{ACCEPT}}} and ΠREJECT{\displaystyle \Pi _{\text{REJECT}}} must be disjoint, i.e. ΠACCEPT∩ΠREJECT=∅{\displaystyle \Pi _{\text{ACCEPT}}\cap \Pi _{\text{REJECT}}=\emptyset }.
The time and space hierarchy theorems form the basis for most separation results of complexity classes. For instance, the time hierarchy theorem establishes that P is strictly contained in EXPTIME, and the space hierarchy theorem establishes that L is strictly contained in PSPACE.
Lee, James R. (May 22, 2014). "Lecture 16" (PDF). CSE431: Introduction to Theory of Computation. University of Washington. Archived (PDF) from the original on November 29, 2021. Retrieved October 5, 2022.
Generally, reductions are used to capture the notion of a problem being at least as difficult as another problem. Thus we are generally interested in using a polynomial-time reduction, since any problem X{\displaystyle X} that can be efficiently reduced to another problem Y{\displaystyle Y} is no more difficult than Y{\displaystyle Y}. Formally, a problem X{\displaystyle X} is polynomial-time reducible to a problem Y{\displaystyle Y} if there exists a polynomial-time computable function p{\displaystyle p} such that for all x∈Σ∗{\displaystyle x\in \Sigma ^{*}}, x∈X{\displaystyle x\in X} if and only if p(x)∈Y{\displaystyle p(x)\in Y}.
While complexity classes defined using Turing machines are described in terms of time complexity, circuit complexity classes are defined in terms of circuit size — the number of vertices in the circuit. The size complexity of a circuit family (C0,C1,C2,...){\displaystyle (C_{0},C_{1},C_{2},...)} is the function f:N→N{\displaystyle f:\mathbb {N} \to \mathbb {N} }, where f(n){\displaystyle f(n)} is the circuit size of Cn{\displaystyle C_{n}}. The familiar function classes follow naturally from this; for example, a polynomial-size circuit family is one such that the function f{\displaystyle f} is a polynomial.
Within this formulation, it can be seen that decision problems are just the subset of promise problems with the trivial promise ΠACCEPT∪ΠREJECT={0,1}∗{\displaystyle \Pi _{\text{ACCEPT}}\cup \Pi _{\text{REJECT}}=\{0,1\}^{*}}. With decision problems it is thus simpler to simply define the problem as only ΠACCEPT{\displaystyle \Pi _{\text{ACCEPT}}} (with ΠREJECT{\displaystyle \Pi _{\text{REJECT}}} implicitly being {0,1}∗/ΠACCEPT{\displaystyle \{0,1\}^{*}/\Pi _{\text{ACCEPT}}}), which throughout this page is denoted L{\displaystyle L} to emphasize that ΠACCEPT=L{\displaystyle \Pi _{\text{ACCEPT}}=L} is a formal language.
P/poly has a number of properties that make it highly useful in the study of the relationships between complexity classes. In particular, it is helpful in investigating problems related to P versus NP. For example, if there is any language in NP that is not in P/poly, then P≠NP{\displaystyle {\mathsf {P}}\neq {\mathsf {NP}}}.[16] P/poly is also helpful in investigating properties of the polynomial hierarchy. For example, if NP ⊆ P/poly, then PH collapses to Σ2P{\displaystyle \Sigma _{2}^{\mathsf {P}}}. A full description of the relations between P/poly and other complexity classes is available at "Importance of P/poly". P/poly is also helpful in the general study of the properties of Turing machines, as the class can be equivalently defined as the class of languages recognized by a polynomial-time Turing machine with a polynomial-bounded advice function.
ZPP, RP and co-RP are all subsets of BPP, which in turn is a subset of PP. The reason for this is intuitive: the classes allowing zero error and only one-sided error are all contained within the class that allows two-sided error, and PP simply relaxes the error probability of BPP. ZPP relates to RP and co-RP in the following way: ZPP=RP∩co-RP{\displaystyle {\textsf {ZPP}}={\textsf {RP}}\cap {\textsf {co-RP}}}. That is, ZPP consists exactly of those problems that are in both RP and co-RP. Intuitively, this follows from the fact that RP and co-RP allow only one-sided error: co-RP does not allow error for strings in the language and RP does not allow error for strings not in the language. Hence, if a problem is in both RP and co-RP, then there must be no error for strings both in and not in the language (i.e. no error whatsoever), which is exactly the definition of ZPP.
And just as NP can be defined both in terms of nondeterminism and in terms of a verifier (i.e. as an interactive proof system), so too can #P be equivalently defined in terms of a verifier. Recall that a decision problem is in NP if there exists a polynomial-time checkable certificate to a given problem instance—that is, NP asks whether there exists a proof of membership (a certificate) for the input that can be checked for correctness in polynomial time. The class #P asks how many such certificates exist.[21] In this context, #P is defined as follows:
Fortnow, Lance (1997). "Counting Complexity" (PDF).In Hemaspaandra, Lane A.; Selman, Alan L. (eds.). Complexity Theory Retrospective II. Springer. pp. 81–106. ISBN 9780387949734. Archived from the original (PDF) on June 18, 2022.
This equivalence between the nondeterministic definition and the verifier definition highlights a fundamental connection between nondeterminism and solution verifiability. Furthermore, it also provides a useful method for proving that a language is in NP—simply identify a suitable certificate and show that it can be verified in polynomial time.
In computational complexity theory, theoretical computer scientists are concerned less with particular runtime values and more with the general class of functions that the time complexity function falls into. For instance, is the time complexity function a polynomial? A logarithmic function? An exponential function? Or another kind of function?
^ a b c d Arora & Barak 2009, p. 344.
Promise problems make for a more natural formulation of many computational problems. For instance, a computational problem could be something like "given a planar graph, determine whether or not..."[25] This is often stated as a decision problem, with it assumed that there is some translation schema that takes every string s∈{0,1}∗{\displaystyle s\in \{0,1\}^{*}} to a planar graph. However, it is more straightforward to define this as a promise problem in which the input is promised to be a planar graph.
2.2Time complexity classes																								2.2.1P and NP																								2.2.1.1The P versus NP problem																														2.2.2EXPTIME and NEXPTIME
L (sometimes lengthened to LOGSPACE) is then defined as the class of problems solvable in logarithmic space on a deterministic Turing machine and NL (sometimes lengthened to NLOGSPACE) is the class of problems solvable in logarithmic space on a nondeterministic Turing machine. Or more formally,[9]
Promise problems provide an alternate definition for standard complexity classes of decision problems. P, for instance, can be defined as a promise problem:[26]
Reductions motivate the concept of a problem being hard for a complexity class. A problem X{\displaystyle X} is hard for a class of problems C if every problem in C can be polynomial-time reduced to X{\displaystyle X}. Thus no problem in C is harder than X{\displaystyle X}, since an algorithm for X{\displaystyle X} allows us to solve any problem in C with at most polynomial slowdown. Of particular importance, the set of problems that are hard for NP is called the set of NP-hard problems.
Counting problems arise in a number of fields, including statistical estimation, statistical physics, network design, and economics.[20]
2Basic complexity classes											Toggle Basic complexity classes subsection																					2.1Basic definitions																											2.2Time complexity classes																								2.2.1P and NP																								2.2.1.1The P versus NP problem																														2.2.2EXPTIME and NEXPTIME																														2.3Space complexity classes																								2.3.1L and NL																											2.3.2PSPACE and NPSPACE																											2.3.3EXPSPACE and NEXPSPACE
DTMs can be viewed as a special case of NTMs that do not make use of the power of nondeterminism. Hence, every computation that can be carried out by a DTM can also be carried out by an equivalent NTM. It is also possible to simulate any NTM using a DTM (the DTM will simply compute every possible computational branch one-by-one). Hence, the two are equivalent in terms of computability. However, simulating an NTM with a DTM often requires greater time and/or memory resources; as will be seen, how significant this slowdown is for certain classes of computational problems is an important question in computational complexity theory.
DSPACE(f(n))⊊DSPACE(f(n)⋅log⁡(f(n))){\displaystyle {\mathsf {DSPACE}}{\big (}f(n){\big )}\subsetneq {\mathsf {DSPACE}}{\big (}f(n)\cdot \log(f(n)){\big )}}
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Aaronson, Scott (8 January 2017). "P=?NP". Electronic Colloquim on Computational Complexity. Weizmann Institute of Science. Archived from the original on June 17, 2020.
EXPTIME (sometimes shortened to EXP) is the class of decision problems solvable by a deterministic Turing machine in exponential time and NEXPTIME (sometimes shortened to NEXP) is the class of decision problems solvable by a nondeterministic Turing machine in exponential time. Or more formally,
The Complexity Zoo Archived 2019-08-27 at the Wayback Machine: A huge list of complexity classes, a reference for experts.
Watrous, John (April 11, 2006). "Lecture 22: Quantum computational complexity" (PDF). University of Waterloo. Archived (PDF) from the original on June 18, 2022.
Promise problems are a generalization of decision problems in which the input to a problem is guaranteed ("promised") to be from a particular subset of all possible inputs. Recall that with a decision problem L⊆{0,1}∗{\displaystyle L\subseteq \{0,1\}^{*}}, an algorithm M{\displaystyle M} for L{\displaystyle L} must act (correctly) on every w∈{0,1}∗{\displaystyle w\in \{0,1\}^{*}}. A promise problem loosens the input requirement on M{\displaystyle M} by restricting the input to some subset of {0,1}∗{\displaystyle \{0,1\}^{*}}.
Two subclasses of P/poly that have interesting properties in their own right are NC and AC. These classes are defined not only in terms of their circuit size but also in terms of their depth. The depth of a circuit is the length of the longest directed path from an input node to the output node. The class NC is the set of languages that can be solved by circuit families that are restricted not only to having polynomial-size but also to having polylogarithmic depth. The class AC is defined similarly to NC, however gates are allowed to have unbounded fan-in (that is, the AND and OR gates can be applied to more than two bits). NC is a notable class because it can be equivalently defined as the class of languages that have efficient parallel algorithms.
The broadest class of efficiently-solvable probabilistic problems is PP (probabilistic polynomial time), the set of languages solvable by a probabilistic Turing machine in polynomial time with an error probability of less than 1/2 for all strings.
Complexity classes group computational problems by their resource requirements. To do this, computational problems are differentiated by upper bounds on the maximum amount of resources that the most efficient algorithm takes to solve them. More specifically, complexity classes are concerned with the rate of growth in the resources required to solve particular computational problems as the input size increases. For example, the amount of time it takes to solve problems in the complexity class P grows at a polynomial rate as the input size increases, which is comparatively slow compared to problems in the exponential complexity class EXPTIME (or more accurately, for problems in EXPTIME that are outside of P, since P⊆EXPTIME{\displaystyle {\mathsf {P}}\subseteq {\mathsf {EXPTIME}}}).
The study of the relationships between complexity classes is a major area of research in theoretical computer science. There are often general hierarchies of complexity classes; for example, it is known that a number of fundamental time and space complexity classes relate to each other in the following way: NL⊆P⊆NP⊆PSPACE⊆EXPTIME⊆EXPSPACE (where ⊆ denotes the subset relation). However, many relationships are not yet known; for example, one of the most famous open problems in computer science concerns whether P equals NP. The relationships between classes often answer questions about the fundamental nature of computation. The P versus NP problem, for instance, is directly related to questions of whether nondeterminism adds any computational power to computers and whether problems having solutions that can be quickly checked for correctness can also be quickly solved.
The following table shows some of the classes of problems that are considered in complexity theory.If class X is a strict subset of Y, then X is shown below Y with a dark line connecting them.If X is a subset, but it is unknown whether they are equal sets, then the line is lighter and dotted. Technically, the breakdown into decidable and undecidable pertains more to the study of computability theory, but is useful for putting the complexity classes in perspective.
Specifically, a promise problem is defined as a pair of non-intersecting sets (ΠACCEPT,ΠREJECT){\displaystyle (\Pi _{\text{ACCEPT}},\Pi _{\text{REJECT}})}, where:[24]
a string w{\displaystyle w} in L{\displaystyle L} implies that Pr[M accepts w]≥1−ϵ{\displaystyle {\text{Pr}}[M{\text{ accepts }}w]\geq 1-\epsilon }
P is the class of problems that are solvable by a deterministic Turing machine in polynomial time and NP is the class of problems that are solvable by a nondeterministic Turing machine in polynomial time. Or more formally,
If a problem X{\displaystyle X} is hard for C and is also in C, then X{\displaystyle X} is said to be complete for C. This means that X{\displaystyle X} is the hardest problem in C (since there could be many problems that are equally hard, more precisely X{\displaystyle X} is as hard as the hardest problems in C).
Formally, a Boolean circuit C{\displaystyle C} is a directed acyclic graph in which edges represent wires (which carry the bit values 0 and 1), the input bits are represented by source vertices (vertices with no incoming edges), and all non-source vertices represent logic gates (generally the AND, OR, and NOT gates). One logic gate is designated the output gate, and represents the end of the computation. The input/output behavior of a circuit C{\displaystyle C} with n{\displaystyle n} input variables is represented by the Boolean function fC:{0,1}n→{0,1}{\displaystyle f_{C}:\{0,1\}^{n}\to \{0,1\}}; for example, on input bits x1,x2,...,xn{\displaystyle x_{1},x_{2},...,x_{n}}, the output bit b{\displaystyle b} of the circuit is represented mathematically as b=fC(x1,x2,...,xn){\displaystyle b=f_{C}(x_{1},x_{2},...,x_{n})}. The circuit C{\displaystyle C} is said to compute the Boolean function fC{\displaystyle f_{C}}.
Neil Immerman. "Computational Complexity Theory". Archived from the original on 2016-04-16. Includes a diagram showing the hierarchy of complexity classes and how they fit together.
A number of classes are defined using interactive proof systems, including the classes IP, MA, and AM
The complexity class P/poly is the set of languages that are decidable by polynomial-size circuit families. It turns out that there is a natural connection between circuit complexity and time complexity. Intuitively, a language with small time complexity (that is, requires relatively few sequential operations on a Turing machine), also has a small circuit complexity (that is, requires relatively few Boolean operations). Formally, it can be shown that if a language is in DTIME(t(n)){\displaystyle {\mathsf {DTIME}}(t(n))}, where t{\displaystyle t} is a function t:N→N{\displaystyle t:\mathbb {N} \to \mathbb {N} }, then it has circuit complexity O(t2(n)){\displaystyle O(t^{2}(n))}.[15] It follows directly from this fact that P⊂P/poly{\displaystyle {\mathsf {\color {Blue}P}}\subset {\textsf {P/poly}}}. In other words, any problem that can be solved in polynomial time by a deterministic Turing machine can also be solved by a polynomial-size circuit family. It is further the case that the inclusion is proper, i.e. P⊊P/poly{\displaystyle {\textsf {P}}\subsetneq {\textsf {P/poly}}} (for example, there are some undecidable problems that are in P/poly).
By definition of DTIME, it follows that DTIME(nk1){\displaystyle {\mathsf {DTIME}}(n^{k_{1}})} is contained in DTIME(nk2){\displaystyle {\mathsf {DTIME}}(n^{k_{2}})} if k1≤k2{\displaystyle k_{1}\leq k_{2}}, since O(nk1)⊆O(nk2){\displaystyle O(n^{k_{1}})\subseteq O(n^{k_{2}})} if k1≤k2{\displaystyle k_{1}\leq k_{2}}. However, this definition gives no indication of whether this inclusion is strict. For time and space requirements, the conditions under which the inclusion is strict are given by the time and space hierarchy theorems, respectively. They are called hierarchy theorems because they induce a proper hierarchy on the classes defined by constraining the respective resources. The hierarchy theorems enable one to make quantitative statements about how much more additional time or space is needed in order to increase the number of problems that can be solved.
Just as FP is the function problem equivalent of P, FNP is the function problem equivalent of NP. Importantly, FP=FNP if and only if P=NP.[23]
A slightly looser class is RP (randomized polynomial time), which maintains no error for strings not in the language but allows bounded error for strings in the language. More formally, a language is in RP if there is a probabilistic polynomial-time Turing machine M{\displaystyle M} such that if a string is not in the language then M{\displaystyle M} always rejects and if a string is in the language then M{\displaystyle M} accepts with a probability at least 1/2. The class co-RP is similarly defined except the roles are flipped: error is not allowed for strings in the language but is allowed for strings not in the language. Taken together, the classes RP and co-RP encompass all of the problems that can be solved by probabilistic Turing machines with one-sided error.
The deterministic Turing machine (DTM) is a variant of the nondeterministic Turing machine (NTM). Intuitively, an NTM is just a regular Turing machine that has the added capability of being able to explore multiple possible future actions from a given state, and "choosing" a branch that accepts (if any accept). That is, while a DTM must follow only one branch of computation, an NTM can be imagined as a computation tree, branching into many possible computational pathways at each step (see image). If at least one branch of the tree halts with an "accept" condition, then the NTM accepts the input. In this way, an NTM can be thought of as simultaneously exploring all computational possibilities in parallel and selecting an accepting branch.[2] NTMs are not meant to be physically realizable models, they are simply theoretically interesting abstract machines that give rise to a number of interesting complexity classes (which often do have physically realizable equivalent definitions).
The flourishing of algebra in the medieval Islamic world, and also in Renaissance Europe, was an outgrowth of the enormous simplification of computation through decimal notation.
The difficulty and unmotivated appearance of these algorithms has long led educators to question this curriculum, advocating the early teaching of more central and intuitive mathematical ideas. One notable movement in this direction was the New Math of the 1960s and 1970s, which attempted to teach arithmetic in the spirit of axiomatic development from set theory, an echo of the prevailing trend in higher mathematics.[19]
Leonardo Pisano – p. 3: "Contributions to number theory" Archived 2008-06-17 at the Wayback Machine. Encyclopædia Britannica Online, 2006. Retrieved 18 September 2006.
The basic arithmetic operations are addition, subtraction, multiplication and division, although arithmetic also includes more advanced operations, such as manipulations of percentages,[6] square roots, exponentiation, logarithmic functions, and even trigonometric functions, in the same vein as logarithms (prosthaphaeresis).Arithmetic expressions must be evaluated according to the intended sequence of operations. There are several methods to specify this, either—most common, together with infix notation—explicitly using parentheses and relying on precedence rules, or using a prefix or postfix notation, which uniquely fix the order of execution by themselves. Any set of objects upon which all four arithmetic operations (except division by zero) can be performed, and where these four operations obey the usual laws (including distributivity), is called a field.[7]
The techniques used in compound unit arithmetic were developed over many centuries and are well documented in many textbooks in many different languages.[12][13][14][15] In addition to the basic arithmetic functions encountered in decimal arithmetic, compound unit arithmetic employs three more functions:
The Works of Archimedes, Chapter IV, Arithmetic in Archimedes, edited by T.L. Heath, Dover Publications Inc, New York, 2002.
Reference: Revue de l'Orient Chretien by François Nau pp. 327–338. (1929)
^ Jacob de Gelder (1824). Allereerste Gronden der Cijferkunst [Introduction to Numeracy] (in Dutch). 's-Gravenhage and Amsterdam: de Gebroeders van Cleef. pp. 163–176. Archived from the original on October 5, 2015. Retrieved March 2, 2011.
In any case, if minuend and subtrahend are equal, the difference D = 0.
Fine, Henry Burchard (1858–1928), The Number System of Algebra Treated Theoretically and Historically, Leach, Shewell & Sanborn, Boston, 1891
Normalization is the conversion of a set of compound units to a standard form—for example, rewriting "1 ft 13 in" as "2 ft 1 in".
Knowledge of the relationship between the various units of measure, their multiples and their submultiples forms an essential part of compound unit arithmetic.
Jacob de Gelder (1824). Allereerste Gronden der Cijferkunst [Introduction to Numeracy] (in Dutch). 's-Gravenhage and Amsterdam: de Gebroeders van Cleef. pp. 163–176. Archived from the original on October 5, 2015. Retrieved March 2, 2011.
Reduction–expansion method where all the compound unit variables are reduced to single unit variables, the calculation performed and the result expanded back to compound units. This approach is suited for automated calculations. A typical example is the handling of time by Microsoft Excel where all time intervals are processed internally as days and decimal fractions of a day.
Reduction, in which a compound quantity is reduced to a single quantity—for example, conversion of a distance expressed in yards, feet and inches to one expressed in inches.[16]
Arithmetic (from Ancient Greekἀριθμός (arithmós) 'number', andτική [τέχνη] (tikḗ [tékhnē]) 'art, craft') is an elementary part of mathematics that consists of the study of the properties of the traditional operations on numbers—addition, subtraction, multiplication, division, exponentiation, and extraction of roots. In the 19th century, Italian mathematician Giuseppe Peano formalized arithmetic with his Peano axioms,[disputed– discuss] which are highly important to the field of mathematical logic today.
Addition is commutative and associative, so the order in which finitely many terms are added does not matter.
Adding finitely many numbers can be viewed as repeated simple addition; this procedure is known as summation, a term also used to denote the definition for "adding infinitely many numbers" in an infinite series. Repeated addition of the number 1 is the most basic form of counting; the result of adding 1 is usually called the successor of the original number.
Métrologie universelle, ancienne et moderne: ou rapport des poids et mesures des empires, royaumes, duchés et principautés des quatre parties du monde
Thomson, J (1824). The Ready Reckoner in miniature containing accurate table from one to the thousand at the various prices from one farthing to one pound. Montreal. ISBN 9780665947063. Archived from the original on 28 July 2013. Retrieved 25 March 2012.
^ Tapson, Frank (1996). The Oxford Mathematics Study Dictionary. Oxford University Press. ISBN 0-19-914551-2.
Expansion, the inverse function to reduction, is the conversion of a quantity that is expressed as a single unit of measure to a compound unit, such as expanding 24 oz to 1 lb 8 oz.
Subtraction, denoted by the symbol −{\displaystyle -}, is the inverse operation to addition. Subtraction finds the difference between two numbers, the minuend minus the subtrahend: D = M − S. Resorting to the previously established addition, this is to say that the difference is the number that, when added to the subtrahend, results in the minuend: D + S = M.[8]
Pages that use a deprecated format of the math tags
The Great Calculation According to the Indians, of Maximus Planudes – an early Western work on arithmetic at Convergence
The addition operation is carried out from right to left; in this case, pence are processed first, then shillings followed by pounds. The numbers below the "answer line" are intermediate results.
The creation of a correct process for multiplication relies on the relationship between values of adjacent digits. The value for any single digit in a numeral depends on its position. Also, each position to the left represents a value ten times larger than the position to the right. In mathematical terms, the exponent for the radix (base) of 10 increases by 1 (to the left) or decreases by 1 (to the right). Therefore, the value for any arbitrary digit is multiplied by a value of the form 10n with integer n. The list of values corresponding to all possible positions for a single digit is written as {..., 102, 10, 1, 10−1, 10−2, ...}.
Algorithms implementing the operation of multiplication for various representations of numbers are by far more costly and laborious than those for addition. Those accessible for manual computation either rely on breaking down the factors to single place values and applying repeated addition, or on employing tables or slide rules, thereby mapping multiplication to addition and vice versa. These methods are outdated and are gradually replaced by mobile devices. Computers use diverse sophisticated and highly optimized algorithms, to implement multiplication and division for the various number formats supported in their system.
Wikipedia articles incorporating a citation from The American Cyclopaedia with a Wikisource reference
The product of a and b is written as a × b or a·b. It can also written by simple juxtaposition: ab. In computer programming languages and software packages (in which one can only use characters normally found on a keyboard), it is often written with an asterisk: a * b.
^ The Works of Archimedes, Chapter IV, Arithmetic in Archimedes, edited by T.L. Heath, Dover Publications Inc, New York, 2002.
Walkingame, Francis (1860). "The Tutor's Companion; or, Complete Practical Arithmetic" (PDF). Webb, Millington & Co. pp. 43–50. Archived from the original (PDF) on 2015-05-04.
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Rudman, Peter Strom (2007). How Mathematics Happened: The First 50,000 Years. Prometheus Books. p. 64. ISBN 978-1-59102-477-4.
Karpinski, Louis Charles (1878–1956), The History of Arithmetic, Rand McNally, Chicago, 1925; reprint: Russell & Russell, New York, 1965
Ore, Øystein, Number Theory and Its History, McGraw–Hill, New York, 1948
Greek numerals were used by Archimedes, Diophantus and others in a positional notation not very different from the modern notation. The ancient Greeks lacked a symbol for zero until the Hellenistic period, and they used three separate sets of symbols as digits: one set for the units place, one for the tens place, and one for the hundreds. For the thousands place, they would reuse the symbols for the units place, and so on. Their addition algorithm was identical to the modern method, and their multiplication algorithm was only slightly different. Their long division algorithm was the same, and the digit-by-digit square root algorithm, popularly used as recently as the 20th century, was known to Archimedes (who may have invented it). He preferred it to Hero's method of successive approximation because, once computed, a digit does not change, and the square roots of perfect squares, such as 7485696, terminate immediately as 2736. For numbers with a fractional part, such as 546.934, they used negative powers of 60—instead of negative powers of 10 for the fractional part 0.934.[2]
On-going normalization method in which each unit is treated separately and the problem is continuously normalized as the solution develops. This approach, which is widely described in classical texts, is best suited for manual calculations. An example of the ongoing normalization method as applied to addition is shown below.
Division, denoted by the symbols ÷{\displaystyle \div } or /{\displaystyle /}, is essentially the inverse operation to multiplication. Division finds the quotient of two numbers, the dividend divided by the divisor. Under common rules, dividend divided by zero is undefined. For distinct positive numbers, if the dividend is larger than the divisor, the quotient is greater than 1, otherwise it is less than or equal to 1 (a similar rule applies for negative numbers). The quotient multiplied by the divisor always yields the dividend.
"Definition of Arithmetic". mathsisfun.com. Archived from the original on 2020-12-31. Retrieved 2020-08-25.
The total in the pence column is 25. Since there are 12 pennies in a shilling, 25 is divided by 12 to give 2 with a remainder of 1. The value "1" is then written to the answer row and the value "2" carried forward to the shillings column. This operation is repeated using the values in the shillings column, with the additional step of adding the value that was carried forward from the pennies column. The intermediate total is divided by 20 as there are 20 shillings in a pound. The pound column is then processed, but as pounds are the largest unit that is being considered, no values are carried forward from the pounds column.
Addition can also be interpreted geometrically, as in the following example.If we have two sticks of lengths 2 and 5, then, if the sticks are aligned one after the other, the length of the combined stick becomes 7, since 2 + 5 = 7.
Multiplication may be viewed as a scaling operation. If the numbers are imagined as lying in a line, multiplication by a number greater than 1, say x, is the same as stretching everything away from 0 uniformly, in such a way that the number 1 itself is stretched to where x was. Similarly, multiplying by a number less than 1 can be imagined as squeezing towards 0, in such a way that 1 goes to the multiplicand.
This page was last edited on 18 February 2023, at 01:59 (UTC).
"Python divmod() Function". W3Schools. Refsnes Data. Archived from the original on 2021-03-13. Retrieved 2021-03-13.
Compound[11] unit arithmetic is the application of arithmetic operations to mixed radix quantities such as feet and inches; gallons and pints; pounds, shillings and pence; and so on. Before decimal-based systems of money and units of measure, compound unit arithmetic was widely used in commerce and industry.
Weil, André, Number Theory: An Approach through History, Birkhauser, Boston, 1984; reviewed: Mathematical Reviews 85c:01004
Until the 19th century, number theory was a synonym of "arithmetic". The addressed problems were directly related to the basic operations and concerned primality, divisibility, and the solution of equations in integers, such as Fermat's Last Theorem. It appeared that most of these problems, although very elementary to state, are very difficult and may not be solved without very deep mathematics involving concepts and methods from many other branches of mathematics. This led to new branches of number theory such as analytic number theory, algebraic number theory, Diophantine geometry and arithmetic algebraic geometry. Wiles' proof of Fermat's Last Theorem is a typical example of the necessity of sophisticated methods, which go far beyond the classical methods of arithmetic, for solving problems that can be stated in elementary arithmetic.
For the sake of simplicity, the example chosen did not have farthings.
O'Connor, John J.; Robertson, Edmund F. (January 2004), "Arithmetic", MacTutor History of Mathematics archive, University of St Andrews
The continuous historical development of modern arithmetic starts with the Hellenistic period of ancient Greece; it originated much later than the Babylonian and Egyptian examples. Prior to the works of Euclid around 300 BC, Greek studies in mathematics overlapped with philosophical and mystical beliefs. Nicomachus is an example of this viewpoint, using the earlier Pythagorean approach to numbers and their relationships to each other in his work Introduction to Arithmetic.
Euclid's Elements first introduced this theorem, and gave a partial proof (which is called Euclid's lemma). The fundamental theorem of arithmetic was first proven by Carl Friedrich Gauss.
Addition, denoted by the symbol +{\displaystyle +}, is the most basic operation of arithmetic. In its simple form, addition combines two numbers, the addends or terms, into a single number, the sum of the numbers (such as 2 + 3 = 5 or 3 + 5 = 8).
The process for multiplying two arbitrary numbers is similar to the process for addition. A multiplication table with ten rows and ten columns lists the results for each pair of digits. If an individual product of a pair of digits exceeds 9, the carry adjustment increases the result of any subsequent multiplication from digits to the left by a value equal to the second (leftmost) digit, which is any value from 1 to 8 (9 × 9 = 81). Additional steps define the final result.
The concept of 0 as a number comparable to the other basic digits is essential to this notation, as is the concept of 0's use as a placeholder, and as is the definition of multiplication and addition with 0. The use of 0 as a placeholder and, therefore, the use of a positional notation is first attested to in the Jain text from India entitled the Lokavibhâga, dated 458 AD and it was only in the early 13th century that these concepts, transmitted via the scholarship of the Arabic world, were introduced into Europe by Fibonacci[10] using the Hindu–Arabic numeral system.
The fundamental theorem of arithmetic states that any integer greater than 1 has a unique prime factorization (a representation of a number as the product of prime factors), excluding the order of the factors. For example, 252 only has one prime factorization:
^ Walkingame, Francis (1860). "The Tutor's Companion; or, Complete Practical Arithmetic" (PDF). Webb, Millington & Co. pp. 43–50. Archived from the original (PDF) on 2015-05-04.
Subtraction is neither commutative nor associative. For that reason, the construction of this inverse operation in modern algebra is often discarded in favor of introducing the concept of inverse elements (as sketched under § Addition), where subtraction is regarded as adding the additive inverse of the subtrahend to the minuend, that is, a − b = a + (−b). The immediate price of discarding the binary operation of subtraction is the introduction of the (trivial) unary operation, delivering the additive inverse for any given number, and losing the immediate access to the notion of difference, which is potentially misleading when negative arguments are involved.
In the Middle Ages, arithmetic was one of the seven liberal arts taught in universities.
Division is neither commutative nor associative. So as explained in § Subtraction, the construction of the division in modern algebra is discarded in favor of constructing the inverse elements with respect to multiplication, as introduced in § Multiplication. Hence division is the multiplication of the dividend with the reciprocal of the divisor as factors, that is, a ÷ b = a × .mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}1/b.
The Great Calculation According to the Indians, of Maximus Planudes
The fundamental theorem of arithmetic is one of the reasons why 1 is not considered a prime number. Other reasons include the sieve of Eratosthenes, and the definition of a prime number itself (a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.).
al-Dumyati, Abd-al-Fattah Bin Abd-al-Rahman al-Banna (1887). "The Best of Arithmetic". World Digital Library (in Arabic). Retrieved 30 June 2013.
Also, arithmetic was used by Islamic Scholars in order to teach application of the rulings related to Zakat and Irth. This was done in a book entitled The Best of Arithmetic by Abd-al-Fattah-al-Dumyati.[20] The book begins with the foundations of mathematics and proceeds to its application in the later chapters.
^ "Python divmod() Function". W3Schools. Refsnes Data. Archived from the original on 2021-03-13. Retrieved 2021-03-13.
Early number systems that included positional notation were not decimal; these include the sexagesimal (base 60) system for Babylonian numerals, and the vigesimal (base 20) system that defined Maya numerals. Because of the place-value concept, the ability to reuse the same digits for different values contributed to simpler and more efficient methods of calculation.
The Ready Reckoner in miniature containing accurate table from one to the thousand at the various prices from one farthing to one pound
^ Joseph Needham, Science and Civilization in China, Vol. 3, p. 9, Cambridge University Press, 1959.
For any representation of numbers, there are methods for calculating results, some of which are particularly advantageous in exploiting procedures, existing for one operation, by small alterations also for others. For example, digital computers can reuse existing adding-circuitry and save additional circuits for implementing a subtraction, by employing the method of two's complement for representing the additive inverses, which is extremely easy to implement in hardware (negation). The trade-off is the halving of the number range for a fixed word length.
A formerly widespread method to achieve a correct change amount, knowing the due and given amounts, is the counting up method, which does not explicitly generate the value of the difference. Suppose an amount P is given in order to pay the required amount Q, with P greater than Q. Rather than explicitly performing the subtraction P − Q = C and counting out that amount C in change, money is counted out starting with the successor of Q, and continuing in the steps of the currency, until P is reached. Although the amount counted out must equal the result of the subtraction P − Q, the subtraction was never really done and the value of P − Q is not supplied by this method.
^ Malaisé, Ferdinand (1842). Theoretisch-Praktischer Unterricht im Rechnen für die niederen Classen der Regimentsschulen der Königl. Bayer. Infantrie und Cavalerie [Theoretical and practical instruction in arithmetic for the lower classes of the Royal Bavarian Infantry and Cavalry School] (in German). Munich. Archived from the original on 25 September 2012. Retrieved 20 March 2012.
Another view on multiplication of integer numbers (extendable to rationals but not very accessible for real numbers) is by considering it as repeated addition. For example. 3 × 4 corresponds to either adding 3 times a 4, or 4 times a 3, giving the same result. There are different opinions on the advantageousness of these paradigmata in math education.
2Arithmetic operations											Toggle Arithmetic operations subsection																					2.1Addition																											2.2Subtraction																											2.3Multiplication																											2.4Division
Dickson, Leonard Eugene, History of the Theory of Numbers (3 volumes), reprints: Carnegie Institute of Washington, Washington, 1932; Chelsea, New York, 1952, 1966
Decimal representation refers exclusively, in common use, to the written numeral system employing arabic numerals as the digits for a radix 10 ("decimal") positional notation; however, any numeral system based on powers of 10, e.g., Greek, Cyrillic, Roman, or Chinese numerals may conceptually be described as "decimal notation" or "decimal representation".
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Rudman, Peter Strom (2007). How Mathematics Happened: The First 50,000 Years. Prometheus Books. p. 64. ISBN 978-1-59102-477-4.
The ancient Chinese had advanced arithmetic studies dating from the Shang Dynasty and continuing through the Tang Dynasty, from basic numbers to advanced algebra. The ancient Chinese used a positional notation similar to that of the Greeks. Since they also lacked a symbol for zero, they had one set of symbols for the units place, and a second set for the tens place. For the hundreds place, they then reused the symbols for the units place, and so on. Their symbols were based on the ancient counting rods. The exact time where the Chinese started calculating with positional representation is unknown, though it is known that the adoption started before 400 BC.[3] The ancient Chinese were the first to meaningfully discover, understand, and apply negative numbers. This is explained in the Nine Chapters on the Mathematical Art (Jiuzhang Suanshu), which was written by Liu Hui dated back to 2nd century BC.
Primary education in mathematics often places a strong focus on algorithms for the arithmetic of natural numbers, integers, fractions, and decimals (using the decimal place-value system). This study is sometimes known as algorism.
^ "Definition of Arithmetic". mathsisfun.com. Archived from the original on 2020-12-31. Retrieved 2020-08-25.
Multiplication is commutative and associative; further, it is distributive over addition and subtraction. The multiplicative identity is 1, since multiplying any number by 1 yields that same number. The multiplicative inverse for any number except 0 is the reciprocal of this number, becausemultiplying the reciprocal of any number by the number itself yields the multiplicative identity 1.0 is the only number without a multiplicative inverse, and the result of multiplying any number and 0 is again 0. One says that 0 is not contained in the multiplicative group of the numbers.
Algorism comprises all of the rules for performing arithmetic computations using this type of written numeral. For example, addition produces the sum of two arbitrary numbers. The result is calculated by the repeated addition of single digits from each number that occupies the same position, proceeding from right to left. An addition table with ten rows and ten columns displays all possible values for each sum. If an individual sum exceeds the value 9, the result is represented with two digits. The rightmost digit is the value for the current position, and the result for the subsequent addition of the digits to the left increases by the value of the second (leftmost) digit, which is always one (if not zero). This adjustment is termed a carry of the value 1.
Modern methods for four fundamental operations (addition, subtraction, multiplication and division) were first devised by Brahmagupta of India. This was known during medieval Europe as "Modus Indorum" or Method of the Indians. Positional notation (also known as "place-value notation") refers to the representation or encoding of numbers using the same symbol for the different orders of magnitude (e.g., the "ones place", "tens place", "hundreds place") and, with a radix point, using those same symbols to represent fractions (e.g., the "tenths place", "hundredths place"). For example, 507.36 denotes 5 hundreds (102), plus 0 tens (101), plus 7 units (100), plus 3 tenths (10−1) plus 6 hundredths (10−2).
a ÷ b = a × .mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}1/b.
Multiplication, denoted by the symbols ×{\displaystyle \times } or ⋅{\displaystyle \cdot }, is the second basic operation of arithmetic. Multiplication also combines two numbers into a single number, the product. The two original numbers are called the multiplier and the multiplicand, mostly both are called factors.
Cunnington, Susan, The Story of Arithmetic: A Short History of Its Origin and Development, Swan Sonnenschein, London, 1904
The number 0 has the property that, when added to any number, it yields that same number; so, it is the identity element of addition, or the additive identity.
Walkingame, Francis (1860). "The Tutor's Companion; or, Complete Practical Arithmetic" (PDF). Webb, Millington & Co. pp. 24–39. Archived from the original (PDF) on 2015-05-04.
The earliest written records indicate the Egyptians and Babylonians used all the elementary arithmetic operations: addition, subtraction, multiplication, and division, as early as 2000 BC. These artifacts do not always reveal the specific process used for solving problems, but the characteristics of the particular numeral system strongly influence the complexity of the methods. The hieroglyphic system for Egyptian numerals, like the later Roman numerals, descended from tally marks used for counting. In both cases, this origin resulted in values that used a decimal base, but did not include positional notation. Complex calculations with Roman numerals required the assistance of a counting board (or the Roman abacus) to obtain the results.
Weyde, P. H. Vander (1879). "Arithmetic" . The American Cyclopædia.
During the 19th and 20th centuries various aids were developed to aid the manipulation of compound units, particularly in commercial applications. The most common aids were mechanical tills which were adapted in countries such as the United Kingdom to accommodate pounds, shillings, pence and farthings, and ready reckoners, which are books aimed at traders that catalogued the results of various routine calculations such as the percentages or multiples of various sums of money. One typical booklet[17] that ran to 150 pages tabulated multiples "from one to ten thousand at the various prices from one farthing to one pound".
5Compound unit arithmetic											Toggle Compound unit arithmetic subsection																					5.1Basic arithmetic operations																											5.2Principles of compound unit arithmetic																											5.3Operations in practice
"Arithmetic". Encyclopedia Britannica. Archived from the original on 2020-11-12. Retrieved 2020-08-25.
Malaisé, Ferdinand (1842). Theoretisch-Praktischer Unterricht im Rechnen für die niederen Classen der Regimentsschulen der Königl. Bayer. Infantrie und Cavalerie [Theoretical and practical instruction in arithmetic for the lower classes of the Royal Bavarian Infantry and Cavalry School] (in German). Munich. Archived from the original on 25 September 2012. Retrieved 20 March 2012.
Theoretisch-Praktischer Unterricht im Rechnen für die niederen Classen der Regimentsschulen der Königl. Bayer. Infantrie und Cavalerie
Joseph Needham, Science and Civilization in China, Vol. 3, p. 9, Cambridge University Press, 1959.
^ al-Dumyati, Abd-al-Fattah Bin Abd-al-Rahman al-Banna (1887). "The Best of Arithmetic". World Digital Library (in Arabic). Retrieved 30 June 2013.
^ Reference: Revue de l'Orient Chretien by François Nau pp. 327–338. (1929)
Palaiseau, JFG (October 1816). Métrologie universelle, ancienne et moderne: ou rapport des poids et mesures des empires, royaumes, duchés et principautés des quatre parties du monde [Universal, ancient and modern metrology: or report of weights and measurements of empires, kingdoms, duchies and principalities of all parts of the world] (in French). Bordeaux. Archived from the original on September 26, 2014. Retrieved October 30, 2011.
^ Thomson, J (1824). The Ready Reckoner in miniature containing accurate table from one to the thousand at the various prices from one farthing to one pound. Montreal. ISBN 9780665947063. Archived from the original on 28 July 2013. Retrieved 25 March 2012.
^ O'Connor, John J.; Robertson, Edmund F. (January 2004), "Arithmetic", MacTutor History of Mathematics archive, University of St Andrews
The prehistory of arithmetic is limited to a small number of artifacts, which may indicate the conception of addition and subtraction, the best-known being the Ishango bone from central Africa, dating from somewhere between 20,000 and 18,000 BC, although its interpretation is disputed.[1]
Within the natural numbers, there is also a different but related notion called Euclidean division, which outputs two numbers after "dividing" a natural N (numerator) by a natural D (denominator): first a natural Q (quotient), and second a natural R (remainder) such that N = D×Q + R and 0 ≤ R < Q.
The gradual development of the Hindu–Arabic numeral system independently devised the place-value concept and positional notation, which combined the simpler methods for computations with a decimal base, and the use of a digit representing 0. This allowed the system to consistently represent both large and small integers—an approach which eventually replaced all other systems. In the early 6th century AD, the Indian mathematician Aryabhata incorporated an existing version of this system in his work, and experimented with different notations. In the 7th century, Brahmagupta established the use of 0 as a separate number, and determined the results for multiplication, division, addition and subtraction of zero and all other numbers—except for the result of division by zero. His contemporary, the Syriac bishop Severus Sebokht (650 AD) said, "Indians possess a method of calculation that no word can praise enough. Their rational system of mathematics, or of their method of calculation. I mean the system using nine symbols."[4] The Arabs also learned this new method and called it hesab.
Repeated multiplication of any value in this list by 10 produces another value in the list. In mathematical terminology, this characteristic is defined as closure, and the previous list is described as closed under multiplication. It is the basis for correctly finding the results of multiplication using the previous technique. This outcome is one example of the uses of number theory.
^ Walkingame, Francis (1860). "The Tutor's Companion; or, Complete Practical Arithmetic" (PDF). Webb, Millington & Co. pp. 24–39. Archived from the original (PDF) on 2015-05-04.
Although the Codex Vigilanus described an early form of Arabic numerals (omitting 0) by 976 AD, Leonardo of Pisa (Fibonacci) was primarily responsible for spreading their use throughout Europe after the publication of his book Liber Abaci in 1202. He wrote, "The method of the Indians (Latin Modus Indorum) surpasses any known method to compute. It's a marvelous method. They do their computations using nine figures and symbol zero".[5]
^ Leonardo Pisano – p. 3: "Contributions to number theory" Archived 2008-06-17 at the Wayback Machine. Encyclopædia Britannica Online, 2006. Retrieved 18 September 2006.
The cumbersome nature of compound unit arithmetic has been recognized for many years—in 1586, the Flemish mathematician Simon Stevin published a small pamphlet called De Thiende ("the tenth")[18] in which he declared the universal introduction of decimal coinage, measures, and weights to be merely a question of time. In the modern era, many conversion programs, such as that included in the Microsoft Windows 7 operating system calculator, display compound units in a reduced decimal format rather than using an expanded format (e.g., "2.5 ft" is displayed rather than "2 ft 6 in").
Various types of tools have been invented and widely used to assist in numeric calculations. Before Renaissance, they were various types of abaci. More recent examples include slide rules, nomograms and mechanical calculators, such as Pascal's calculator. At present, they have been supplanted by electronic calculators and computers.
^ "Arithmetic". Encyclopedia Britannica. Archived from the original on 2020-11-12. Retrieved 2020-08-25.
^ Palaiseau, JFG (October 1816). Métrologie universelle, ancienne et moderne: ou rapport des poids et mesures des empires, royaumes, duchés et principautés des quatre parties du monde [Universal, ancient and modern metrology: or report of weights and measurements of empires, kingdoms, duchies and principalities of all parts of the world] (in French). Bordeaux. Archived from the original on September 26, 2014. Retrieved October 30, 2011.
Tapson, Frank (1996). The Oxford Mathematics Study Dictionary. Oxford University Press. ISBN 0-19-914551-2.
In some contexts, including computer programming and advanced arithmetic, division is extended with another output for the remainder. This is often treated as a separate operation, the Modulo operation, denoted by the symbol %{\displaystyle \%} or the word mod{\displaystyle mod}, though sometimes a second output for one "divmod" operation.[9] In either case, Modular arithmetic has a variety of use cases. Different implementations of division (floored, truncated, Euclidean, etc.) correspond with different implementations of modulus.
whose values are to be estimated. Third, the continuous probability density function (pdf) or its discrete counterpart, the probability mass function (pmf), of the underlying distribution that generated the data must be stated conditional on the values of the parameters:
Measured data are likely to be subject to noise or uncertainty and it is through statistical probability that optimal solutions are sought to extract as much information from the data as possible.
^ Johnson, Roger (2006), "Estimating the Size of a Population", Getting the Best from Teaching Statistics, archived from the original (PDF) on November 20, 2008
4.1Unknown constant in additive white Gaussian noise																								4.1.1Maximum likelihood																											4.1.2Cramér–Rao lower bound
Commonly used estimators (estimation methods) and topics related to them include:
The sample maximum is never more than the population maximum, but can be less, hence it is a biased estimator: it will tend to underestimate the population maximum.
A^2=1N∑n=0N−1x[n]{\displaystyle {\hat {A}}_{2}={\frac {1}{N}}\sum _{n=0}^{N-1}x[n]} which is the sample mean
One of the simplest non-trivial examples of estimation is the estimation of the maximum of a uniform distribution. It is used as a hands-on classroom exercise and to illustrate basic principles of estimation theory. Further, in the case of estimation based on a single sample, it demonstrates philosophical issues and possible misunderstandings in the use of maximum likelihood estimators and likelihood functions.
It is also possible for the parameters themselves to have a probability distribution (e.g., Bayesian statistics). It is then necessary to define the Bayesian probability
4Examples											Toggle Examples subsection																					4.1Unknown constant in additive white Gaussian noise																								4.1.1Maximum likelihood																											4.1.2Cramér–Rao lower bound																														4.2Maximum of a uniform distribution
Or, for example, in radar the aim is to find the range of objects (airplanes, boats, etc.) by analyzing the two-way transit timing of received echoes of transmitted pulses. Since the reflected pulses are unavoidably embedded in electrical noise, their measured values are randomly distributed, so that the transit time must be estimated.
ln⁡p(x;A)=−Nln⁡(σ2π)−12σ2∑n=0N−1(x[n]−A)2{\displaystyle \ln p(\mathbf {x} ;A)=-N\ln \left(\sigma {\sqrt {2\pi }}\right)-{\frac {1}{2\sigma ^{2}}}\sum _{n=0}^{N-1}(x[n]-A)^{2}}
which is simply the sample mean.From this example, it was found that the sample mean is the maximum likelihood estimator for N{\displaystyle N} samples of a fixed, unknown parameter corrupted by AWGN.
∂∂Aln⁡p(x;A)=1σ2[∑n=0N−1(x[n]−A)]=1σ2[∑n=0N−1x[n]−NA]{\displaystyle {\frac {\partial }{\partial A}}\ln p(\mathbf {x} ;A)={\frac {1}{\sigma ^{2}}}\left[\sum _{n=0}^{N-1}(x[n]-A)\right]={\frac {1}{\sigma ^{2}}}\left[\sum _{n=0}^{N-1}x[n]-NA\right]}
Mathematical Statistics and Data Analysis by John Rice. (ISBN 0-534-209343)
This page was last edited on 10 February 2023, at 06:28 (UTC).
so a standard deviation of approximately N/k{\displaystyle N/k}, the (population) average size of a gap between samples; compare mk{\displaystyle {\frac {m}{k}}} above. This can be seen as a very simple case of maximum spacing estimation.
Fundamentals of Statistical Signal Processing: Estimation Theory by Steven M. Kay (ISBN 0-13-345711-7)
At this point, these two estimators would appear to perform the same.However, the difference between them becomes apparent when comparing the variances.
E[A^2]=E[1N∑n=0N−1x[n]]=1N[∑n=0N−1E[x[n]]]=1N[NA]=A{\displaystyle \mathrm {E} \left[{\hat {A}}_{2}\right]=\mathrm {E} \left[{\frac {1}{N}}\sum _{n=0}^{N-1}x[n]\right]={\frac {1}{N}}\left[\sum _{n=0}^{N-1}\mathrm {E} \left[x[n]\right]\right]={\frac {1}{N}}\left[NA\right]=A}
^ a b Johnson, Roger (1994), "Estimating the Size of a Population", Teaching Statistics, 16 (2 (Summer)): 50–52, doi:10.1111/j.1467-9639.1994.tb00688.x
−E[∂2∂A2ln⁡p(x;A)]=Nσ2{\displaystyle -\mathrm {E} \left[{\frac {\partial ^{2}}{\partial A^{2}}}\ln p(\mathbf {x} ;A)\right]={\frac {N}{\sigma ^{2}}}}
Consider a received discrete signal, x[n]{\displaystyle x[n]}, of N{\displaystyle N} independent samples that consists of an unknown constant A{\displaystyle A} with additive white Gaussian noise (AWGN) w[n]{\displaystyle w[n]} with zero mean and known variance σ2{\displaystyle \sigma ^{2}} (i.e., N(0,σ2){\displaystyle {\mathcal {N}}(0,\sigma ^{2})}).Since the variance is known then the only unknown parameter is A{\displaystyle A}.
the gap being added to compensate for the negative bias of the sample maximum as an estimator for the population maximum.[note 1]
^ The sample maximum is never more than the population maximum, but can be less, hence it is a biased estimator: it will tend to underestimate the population maximum.
Numerous fields require the use of estimation theory.Some of these fields include:
var(A^2)=var(1N∑n=0N−1x[n])=independence1N2[∑n=0N−1var(x[n])]=1N2[Nσ2]=σ2N{\displaystyle \mathrm {var} \left({\hat {A}}_{2}\right)=\mathrm {var} \left({\frac {1}{N}}\sum _{n=0}^{N-1}x[n]\right){\overset {\text{independence}}{=}}{\frac {1}{N^{2}}}\left[\sum _{n=0}^{N-1}\mathrm {var} (x[n])\right]={\frac {1}{N^{2}}}\left[N\sigma ^{2}\right]={\frac {\sigma ^{2}}{N}}}
It would seem that the sample mean is a better estimator since its variance is lower for every N > 1.
and the probability of x[n]{\displaystyle x[n]} becomes (x[n]{\displaystyle x[n]} can be thought of a N(A,σ2){\displaystyle {\mathcal {N}}(A,\sigma ^{2})})
As another example, in electrical communication theory, the measurements which contain information regarding the parameters of interest are often associated with a noisy signal.
To find the Cramér–Rao lower bound (CRLB) of the sample mean estimator, it is first necessary to find the Fisher information number
Ali H. Sayed, Fundamentals of Adaptive Filtering, Wiley, NJ, 2003, ISBN 0-471-46126-1.
Comparing this to the variance of the sample mean (determined previously) shows that the sample mean is equal to the Cramér–Rao lower bound for all values of N{\displaystyle N} and A{\displaystyle A}.In other words, the sample mean is the (necessarily unique) efficient estimator, and thus also the minimum variance unbiased estimator (MVUE), in addition to being the maximum likelihood estimator.
Both of these estimators have a mean of A{\displaystyle A}, which can be shown through taking the expected value of each estimator
∂∂Aln⁡p(x;A)=1σ2[∑n=0N−1x[n]−NA]{\displaystyle {\frac {\partial }{\partial A}}\ln p(\mathbf {x} ;A)={\frac {1}{\sigma ^{2}}}\left[\sum _{n=0}^{N-1}x[n]-NA\right]}
Minimum mean squared error (MMSE), also known as Bayes least squared error (BLSE)
One common estimator is the minimum mean squared error (MMSE) estimator, which utilizes the error between the estimated parameters and the actual value of the parameters
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Walter, E.; Pronzato, L. (1997). Identification of Parametric Models from Experimental Data. London, England: Springer-Verlag.
Two possible (of many) estimators for the parameter A{\displaystyle A} are:
1k(N−k)(N+1)(k+2)≈N2k2 for small samples k≪N{\displaystyle {\frac {1}{k}}{\frac {(N-k)(N+1)}{(k+2)}}\approx {\frac {N^{2}}{k^{2}}}{\text{ for small samples }}k\ll N}
Johnson, Roger (1994), "Estimating the Size of a Population", Teaching Statistics, 16 (2 (Summer)): 50–52, doi:10.1111/j.1467-9639.1994.tb00688.x
V.G.Voinov, M.S.Nikulin, "Unbiased estimators and their applications. Vol.2: Multivariate case",Kluwer Academic Publishers, 1996, ISBN 0-7923-3939-8.
The sample maximum is the maximum likelihood estimator for the population maximum, but, as discussed above, it is biased.
For a given model, several statistical "ingredients" are needed so the estimator can be implemented. The first is a statistical sample – a set of data points taken from a random vector (RV) of size N. Put into a vector,
After the model is formed, the goal is to estimate the parameters, with the estimates commonly denoted θ^{\displaystyle {\hat {\boldsymbol {\theta }}}}, where the "hat" indicates the estimate.
Johnson, Roger (2006), "Estimating the Size of a Population", Getting the Best from Teaching Statistics, archived from the original (PDF) on November 20, 2008
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Walter, E.; Pronzato, L. (1997). Identification of Parametric Models from Experimental Data. London, England: Springer-Verlag.
For example, it is desired to estimate the proportion of a population of voters who will vote for a particular candidate.That proportion is the parameter sought; the estimate is based on a small random sample of voters. Alternatively, it is desired to estimate the probability of a voter voting for a particular candidate, based on some demographic features, such as age.
The probabilistic approach (described in this article) assumes that the measured data is random with probability distribution dependent on the parameters of interest
An Introduction to Signal Detection and Estimation by H. Vincent Poor (ISBN 0-387-94173-8)
∂2∂A2ln⁡p(x;A)=1σ2(−N)=−Nσ2{\displaystyle {\frac {\partial ^{2}}{\partial A^{2}}}\ln p(\mathbf {x} ;A)={\frac {1}{\sigma ^{2}}}(-N)={\frac {-N}{\sigma ^{2}}}}
and finding the negative expected value is trivial since it is now a deterministic constant−E[∂2∂A2ln⁡p(x;A)]=Nσ2{\displaystyle -\mathrm {E} \left[{\frac {\partial ^{2}}{\partial A^{2}}}\ln p(\mathbf {x} ;A)\right]={\frac {N}{\sigma ^{2}}}}
Given a discrete uniform distribution 1,2,…,N{\displaystyle 1,2,\dots ,N} with unknown maximum, the UMVU estimator for the maximum is given by
By independence, the probability of x{\displaystyle \mathbf {x} } becomes
Theory of Point Estimation by E.L. Lehmann and G. Casella. (ISBN 0387985026)
Babak Hassibi, Ali H. Sayed, and Thomas Kailath, Indefinite Quadratic Estimation and Control: A Unified Approach to H2 and H∞{\displaystyle \infty } Theories, Society for Industrial & Applied Mathematics (SIAM), PA, 1999, ISBN 978-0-89871-411-1.
as the basis for optimality.This error term is then squared and the expected value of this squared value is minimized for the MMSE estimator.
Continuing the example using the maximum likelihood estimator, the probability density function (pdf) of the noise for one sample w[n]{\displaystyle w[n]} is
where m is the sample maximum and k is the sample size, sampling without replacement.[2][3] This problem is commonly known as the German tank problem, due to application of maximum estimation to estimates of German tank production during World War II.
Ali H. Sayed, Adaptive Filters, Wiley, NJ, 2008, ISBN 978-0-470-25388-5.
V.G.Voinov, M.S.Nikulin, "Unbiased estimators and their applications. Vol.1: Univariate case",Kluwer Academic Publishers, 1993, ISBN 0-7923-2382-3.
Estimation theory is a branch of statistics that deals with estimating the values of parameters based on measured empirical data that has a random component.The parameters describe an underlying physical setting in such a way that their value affects the distribution of the measured data. An estimator attempts to approximate the unknown parameters using the measurements.In estimation theory, two approaches are generally considered:[1]
The set-membership approach assumes that the measured data vector belongs to a set which depends on the parameter vector.
Thomas Kailath, Ali H. Sayed, and Babak Hassibi, Linear Estimation, Prentice-Hall, NJ, 2000, ISBN 978-0-13-022464-4.
I(A)=E([∂∂Aln⁡p(x;A)]2)=−E[∂2∂A2ln⁡p(x;A)]{\displaystyle {\mathcal {I}}(A)=\mathrm {E} \left(\left[{\frac {\partial }{\partial A}}\ln p(\mathbf {x} ;A)\right]^{2}\right)=-\mathrm {E} \left[{\frac {\partial ^{2}}{\partial A^{2}}}\ln p(\mathbf {x} ;A)\right]}
p(x;A)=∏n=0N−1p(x[n];A)=1(σ2π)Nexp⁡(−12σ2∑n=0N−1(x[n]−A)2){\displaystyle p(\mathbf {x} ;A)=\prod _{n=0}^{N-1}p(x[n];A)={\frac {1}{\left(\sigma {\sqrt {2\pi }}\right)^{N}}}\exp \left(-{\frac {1}{2\sigma ^{2}}}\sum _{n=0}^{N-1}(x[n]-A)^{2}\right)}
The quotient is most frequently encountered as two numbers, or two variables, divided by a horizontal line.The words "dividend" and "divisor" refer to each individual part, while the word "quotient" refers to the whole.
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Quotient". Dictionary.com.
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Quotient". Dictionary.com.
^ "Irrationality of the square root of 2". www.math.utah.edu. Retrieved 2020-08-27.
"Irrationality of the square root of 2". www.math.utah.edu. Retrieved 2020-08-27.
Outside of arithmetic, many branches of mathematics have borrowed the word "quotient" to describe structures built by breaking larger structures into pieces. Given a set with an equivalence relation defined on it, a "quotient set" may be created which contains those equivalence classes as elements. A quotient group may be formed by breaking a group into a number of similar cosets, while a quotient space may be formed in a similar process by breaking a vector space into a number of similar linear subspaces.
A rational number can be defined as the quotient of two integers (as long as the denominator is non-zero).
The existence of irrational numbers—numbers that are not a quotient of two integers—was first discovered in geometry, in such things as the ratio of the diagonal to the side in a square.[5]
In arithmetic, a quotient (from Latin: quotiens 'how many times', pronounced /ˈkwoʊʃənt/) is a quantity produced by the division of two numbers.[1]The quotient has widespread use throughout mathematics, and is commonly referred to as the integer part of a division (in the case of Euclidean division),[2] or as a fraction or a ratio (in the case of proper division).For example, when dividing 20 (the dividend) by 3 (the divisor), the quotient is "6 with a remainder of 2" in the Euclidean division sense, and 623{\displaystyle 6{\tfrac {2}{3}}} in the proper division sense. In the second sense, a quotient is simply the ratio of a dividend to its divisor.
Quotient of a formal language, also left and right quotient
Epp, Susanna S. (2011-01-01). Discrete mathematics with applications. Brooks/Cole. p. 163. ISBN 9780495391326. OCLC 970542319.
This page was last edited on 4 July 2022, at 08:27 (UTC).
^ Epp, Susanna S. (2011-01-01). Discrete mathematics with applications. Brooks/Cole. p. 163. ISBN 9780495391326. OCLC 970542319.
dividenddivisor numeratordenominator}={\displaystyle \scriptstyle \left.{\begin{matrix}\scriptstyle {\frac {\scriptstyle {\text{dividend}}}{\scriptstyle {\text{divisor}}}}\\\scriptstyle {\text{ }}\\\scriptstyle {\frac {\scriptstyle {\text{numerator}}}{\scriptstyle {\text{denominator}}}}\end{matrix}}\right\}\,=\,}
The quotient is also less commonly defined as the greatest whole number of times a divisor may be subtracted from a dividend—before making the remainder negative. For example, the divisor 3 may be subtracted up to 6 times from the dividend 20, before the remainder becomes negative:
In this sense, a quotient is the integer part of the ratio of two numbers.[3]
Division of any number by zero in most mathematical systems is undefined, because zero multiplied by any finite number always results in a product of zero.[14] Entry of such an expression into most calculators produces an error message. However, in certain higher level mathematics division by zero is possible by the zero ring and algebras such as wheels.[15] In these algebras, the meaning of division is different from traditional definitions.
Divisibility rules can sometimes be used to quickly determine whether one integer divides exactly into another.
^ Jesper Carlström. "On Division by Zero" Archived 2019-08-17 at the Wayback Machine Retrieved October 23, 2018
Because matrix multiplication is not commutative, one can also define a left division or so-called backslash-division as A \ B = A−1B. For this to be well defined, B−1 need not exist, however A−1 does need to exist. To avoid confusion, division as defined by A / B = AB−1 is sometimes called right division or slash-division in this context.
Smith, David Eugene (1925). History Of Mathematics Vol II. Ginn And Company.
Since the 19th century, US textbooks have used b)a{\displaystyle b)a} or b)a¯{\displaystyle b{\overline {)a}}} to denote a divided by b, especially when discussing long division. The history of this notation is not entirely clear because it evolved over time.[12]
^ Smith, David Eugene (1925). History Of Mathematics Vol II. Ginn And Company.
^ Thomas Sonnabend (2010). Mathematics for Teachers: An Interactive Approach for Grades K–8. Brooks/Cole, Cengage Learning (Charles Van Wagner). p. 126. ISBN 978-0-495-56166-8.
Integers are not closed under division. Apart from division by zero being undefined, the quotient is not an integer unless the dividend is an integer multiple of the divisor. For example, 26 cannot be divided by 11 to give an integer. Such a case uses one of five approaches:
This page was last edited on 15 January 2023, at 13:36 (UTC).
Division for complex numbers expressed in polar form is simpler than the definition above:
Give an approximate answer as a floating-point number. This is the approach usually taken in numerical computation.
Division by zero may be defined in some circumstances, either by extending the real numbers to the extended real number line or to the projectively extended real line or when occurring as limit of divisions by numbers tending to 0. For example: limx→0 sin x/x = 1.[2][3]
Logarithm tables can be used to divide two numbers, by subtracting the two numbers' logarithms, then looking up the antilogarithm of the result.
One can define the division operation for polynomials in one variable over a field. Then, as in the case of integers, one has a remainder. See Euclidean division of polynomials, and, for hand-written computation, polynomial long division or synthetic division.
^ http://www.mathwords.com/c/commutative.htm Archived 2018-10-28 at the Wayback Machine Retrieved October 23, 2018
"Division" in the sense of "cancellation" can be done in any magma by an element with the cancellation property.Examples include matrix algebras and quaternion algebras.A quasigroup is a structure in which division is always possible, even without an identity element and hence inverses.In an integral domain, where not every element need have an inverse, division by a cancellative element a can still be performed on elements of the form ab or ca by left or right cancellation, respectively.If a ring is finite and every nonzero element is cancellative, then by an application of the pigeonhole principle, every nonzero element of the ring is invertible, and division by any nonzero element is possible. To learn about when algebras (in the technical sense) have a division operation, refer to the page on division algebras. In particular Bott periodicity can be used to show that any real normed division algebra must be isomorphic to either the real numbers R, the complex numbers C, the quaternions H, or the octonions O.
dividenddivisor numeratordenominator}={\displaystyle \scriptstyle \left.{\begin{matrix}\scriptstyle {\frac {\scriptstyle {\text{dividend}}}{\scriptstyle {\text{divisor}}}}\\\scriptstyle {\text{ }}\\\scriptstyle {\frac {\scriptstyle {\text{numerator}}}{\scriptstyle {\text{denominator}}}}\end{matrix}}\right\}\,=\,}
Division is one of the four basic operations of arithmetic, the ways that numbers are combined to make new numbers. The other operations are addition, subtraction, and multiplication.
The result of dividing two rational numbers is another rational number when the divisor is not 0. The division of two rational numbers p/q and r/s can be computed as
This process of multiplying and dividing by r−is{\displaystyle r-is} is called 'realisation' or (by analogy) rationalisation. All four quantities p, q, r, s are real numbers, and r and s may not both be 0.
Derbyshire, John (2004). Prime Obsession: Bernhard Riemann and the Greatest Unsolved Problem in Mathematics. New York City: Penguin Books. ISBN 978-0-452-28525-5.
George Mark Bergman: Order of arithmetic operations Archived 2017-03-05 at the Wayback Machine
^ http://www.mathwords.com/a/associative_operation.htm Archived 2018-10-28 at the Wayback Machine Retrieved October 23, 2018
Division of two real numbers results in another real number (when the divisor is nonzero). It is defined such that a/b = c if and only if a = cb and b ≠ 0.
Both forms of division appear in various algebraic structures, different ways of defining mathematical structure. Those in which a Euclidean division (with remainder) is defined are called Euclidean domains and include polynomial rings in one indeterminate (which define multiplication and addition over single-variabled formulas). Those in which a division (with a single result) by all nonzero elements is defined are called fields and division rings. In a ring the elements by which division is always possible are called the units (for example, 1 and −1 in the ring of integers). Another generalization of division to algebraic structures is the quotient group, in which the result of "division" is a group rather than a number.
The derivative of the quotient of two functions is given by the quotient rule:
^ Education Place: The Order of Operations Archived 2017-06-08 at the Wayback Machine
http://mathworld.wolfram.com/DivisionbyZero.html Archived 2018-10-23 at the Wayback Machine Retrieved October 23, 2018
For division to always yield one number rather than a quotient plus a remainder, the natural numbers must be extended to rational numbers or real numbers. In these enlarged number systems, division is the inverse operation to multiplication, that is a = c / b means a × b = c, as long as b is not zero. If b = 0, then this is a division by zero, which is not defined.[a][4]: 246  In the 21-apples example, everyone would receive 5 apple and a quarter of an apple, thus avoiding any leftover.
Unlike the other basic operations, when dividing natural numbers there is sometimes a remainder that will not go evenly into the dividend; for example, 10 / 3 leaves a remainder of 1, as 10 is not a multiple of 3. Sometimes this remainder is added to the quotient as a fractional part, so 10 / 3 is equal to 3+1/3 or 3.33..., but in the context of integer division, where numbers have no fractional part, the remainder is kept separately (or exceptionally, discarded or rounded).[5] When the remainder is kept as a fraction, it leads to a rational number. The set of all rational numbers is created by extending the integers with all possible results of divisions of integers.
The division with remainder or Euclidean division of two natural numbers provides an integer quotient, which is the number of times the second number is completely contained in the first number, and a remainder, which is the part of the first number that remains, when in the course of computing the quotient, no further full chunk of the size of the second number can be allocated. For example, if 21 apples are divided between 4 people, everyone receives 5 apples again, and 1 apple remains.
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Blake, A. G. (1887). Arithmetic. Dublin, Ireland: Alexander Thom & Company.
Modern calculators and computers compute division either by methods similar to long division, or by faster methods; see Division algorithm.
.mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}20/5 = 4
All four quantities are integers, and only p may be 0. This definition ensures that division is the inverse operation of multiplication.
By allowing one to subtract more multiples than what the partial remainder allows at a given stage, more flexible methods, such as the bidirectional variant of chunking, can be developed as well.
This form is infrequent except in elementary arithmetic. ISO 80000-2-9.6 states it should not be used. This division sign is also used alone to represent the division operation itself, as for instance as a label on a key of a calculator. The obelus was introduced by Swiss mathematician Johann Rahn in 1659 in Teutsche Algebra.[10]: 211  The ÷ symbol is used to indicate subtraction in some European countries, so its use may be misunderstood.
Note that with left and right division defined this way, A / (BC) is in general not the same as (A / B) / C, nor is (AB) \ C the same as A \ (B \ C). However, it holds that A / (BC) = (A / C) / B and (AB) \ C = B \ (A \ C).
In modular arithmetic (modulo a prime number) and for real numbers, nonzero numbers have a multiplicative inverse. In these cases, a division by x may be computed as the product by the multiplicative inverse of x. This approach is often associated with the faster methods in computer arithmetic.
To avoid problems when A−1 and/or B−1 do not exist, division can also be defined as multiplication by the pseudoinverse. That is, A / B = AB+ and A \ B = A+B, where A+ and B+ denote the pseudoinverses of A and B.
Division is often shown in algebra and science by placing the dividend over the divisor with a horizontal line, also called a fraction bar, between them. For example, "a divided by b" can written as:
Division can be calculated with a slide rule by aligning the divisor on the C scale with the dividend on the D scale. The quotient can be found on the D scale where it is aligned with the left index on the C scale. The user is responsible, however, for mentally keeping track of the decimal point.
Division is often introduced through the notion of "sharing out" a set of objects, for example a pile of lollies, into a number of equal portions. Distributing the objects several at a time in each round of sharing to each portion leads to the idea of 'chunking' –a form of division where one repeatedly subtracts multiples of the divisor from the dividend itself.
Again all four quantities p, q, r, s are real numbers, and r may not be 0.
Give the answer as an integer quotient and a remainder, so 2611=2 remainder 4.{\displaystyle {\tfrac {26}{11}}=2{\mbox{ remainder }}4.} To make the distinction with the previous case, this division, with two integers as result, is sometimes called Euclidean division, because it is the basis of the Euclidean algorithm.
This notation was introduced by Gottfried Wilhelm Leibniz in his 1684 Acta eruditorum.[10]: 295  Leibniz disliked having separate symbols for ratio and division. However, in English usage the colon is restricted to expressing the related concept of ratios.
Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: "Division" mathematics – news · newspapers · books · scholar · JSTOR
This is unlike the case in multiplication, which is both left-distributive and right-distributive, and thus distributive.
This is the same for multiplication, as (a+b)×c=a×c+b×c{\displaystyle (a+b)\times c=a\times c+b\times c}. However, division is not left-distributive, as
Say that 26 cannot be divided by 11; division becomes a partial function.
which can also be read out loud as "divide a by b" or "a over b". A way to express division all on one line is to write the dividend (or numerator), then a slash, then the divisor (or denominator), as follows:
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Blake, A. G. (1887). Arithmetic. Dublin, Ireland: Alexander Thom & Company.
This is the usual way of specifying division in most computer programming languages, since it can easily be typed as a simple sequence of ASCII characters. (It is also the only notation used for quotient objects in abstract algebra.) Some mathematical software, such as MATLAB and GNU Octave, allows the operands to be written in the reverse order by using the backslash as the division operator:
4Division in different contexts											Toggle Division in different contexts subsection																					4.1Euclidean division																											4.2Of integers																											4.3Of rational numbers																											4.4Of real numbers																											4.5Of complex numbers																											4.6Of polynomials																											4.7Of matrices																								4.7.1Left and right division																											4.7.2Pseudoinverse																														4.8Abstract algebra																											4.9Calculus
http://www.mathwords.com/c/commutative.htm Archived 2018-10-28 at the Wayback Machine Retrieved October 23, 2018
^ http://mathworld.wolfram.com/DivisionbyZero.html Archived 2018-10-23 at the Wayback Machine Retrieved October 23, 2018
^ Division by zero may be defined in some circumstances, either by extending the real numbers to the extended real number line or to the projectively extended real line or when occurring as limit of divisions by numbers tending to 0. For example: limx→0 sin x/x = 1.[2][3]
^ Kojima, Takashi (2012-07-09). Advanced Abacus: Theory and Practice. Tuttle Publishing. ISBN 978-1-4629-0365-8.
Thomas Sonnabend (2010). Mathematics for Teachers: An Interactive Approach for Grades K–8. Brooks/Cole, Cengage Learning (Charles Van Wagner). p. 126. ISBN 978-0-495-56166-8.
Cajori, Florian (1929). A History of Mathematical Notations. Open Court Pub. Co.
^ George Mark Bergman: Order of arithmetic operations Archived 2017-03-05 at the Wayback Machine
Kojima, Takashi (2012-07-09). Advanced Abacus: Theory and Practice. Tuttle Publishing. ISBN 978-1-4629-0365-8.
Dividing integers in a computer program requires special care. Some programming languages treat integer division as in case 5 above, so the answer is an integer. Other languages, such as MATLAB and every computer algebra system return a rational number as the answer, as in case 3 above. These languages also provide functions to get the results of the other cases, either directly or from the result of case 3.
The simplest way of viewing division is in terms of quotition and partition: from the quotition perspective, 20 / 5 means the number of 5s that must be added to get 20. In terms of partition, 20 / 5 means the size of each of 5 parts into which a set of size 20 is divided. For example, 20 apples divide into five groups of four apples, meaning that twenty divided by five is equal to four. This is denoted as 20 / 5 = 4, or .mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}20/5 = 4.[2] What is being divided is called the dividend, which is divided by the divisor, and the result is called the quotient. In the example, 20 is the dividend, 5 is the divisor, and 4 is the quotient.
Dividing two complex numbers (when the divisor is nonzero) results in another complex number, which is found using the conjugate of the denominator:
Find sources: "Division" mathematics – news · newspapers · books · scholar · JSTOR
Unlike multiplication and addition, division is not commutative, meaning that a / b is not always equal to b / a.[6] Division is also not, in general, associative, meaning that when dividing multiple times, the order of division can change the result.[7] For example, (24 / 6) / 2 = 2, but 24 / (6 / 2) = 8 (where the use of parentheses indicates that the operations inside parentheses are performed before the operations outside parentheses).
Euclidean division is the mathematical formulation of the outcome of the usual process of division of integers. It asserts that, given two integers, a, the dividend, and b, the divisor, such that b ≠ 0, there are unique integers q, the quotient, and r, the remainder,such that a = bq + r and 0 ≤ r < |b|, where |b| denotes the absolute value of b.
A typographical variation halfway between these two forms uses a solidus (fraction slash), but elevates the dividend and lowers the divisor:
Give the integer quotient as the answer, so 2611=2.{\displaystyle {\tfrac {26}{11}}=2.} This is the floor function applied to case 2 or 3. It is sometimes called integer division, and denoted by "//".
Division is traditionally considered as left-associative. That is, if there are multiple divisions in a row, the order of calculation goes from left to right:[8][9]
At an elementary level the division of two natural numbers is, among other possible interpretations, the process of calculating the number of times one number is contained within another.[1]: 7  This number of times need not be an integer. For example, if 20 apples are divided evenly between 4 people, everyone receives 5 apples (see picture).
One can define a division operation for matrices. The usual way to do this is to define A / B = AB−1, where B−1 denotes the inverse of B, but it is far more common to write out AB−1 explicitly to avoid confusion. An elementwise division can also be defined in terms of the Hadamard product.
More systematically and more efficiently, two integers can be divided with pencil and paper with the method of short division, if the divisor is small, or long division, if the divisor is larger. If the dividend has a fractional part (expressed as a decimal fraction), one can continue the procedure past the ones place as far as desired. If the divisor has a fractional part, one can restate the problem by moving the decimal to the right in both numbers until the divisor has no fraction, which can make the problem easier to solve (e.g., 10/2.5 = 100/25 = 4).
In abstract algebra, given a magma with binary operation ∗ (which could nominally be termed multiplication), left division of b by a (written a \ b) is typically defined as the solution x to the equation a ∗ x = b, if this exists and is unique.Similarly, right division of b by a (written b / a) is the solution y to the equation y ∗ a = b.Division in this sense does not require ∗ to have any particular properties (such as commutativity, associativity, or an identity element).
Education Place: The Order of Operations Archived 2017-06-08 at the Wayback Machine
Division is right-distributive over addition and subtraction, in the sense that
Division on a Japanese abacus selected from Abacus: Mystery of the Bead
http://www.mathwords.com/a/associative_operation.htm Archived 2018-10-28 at the Wayback Machine Retrieved October 23, 2018
Give the answer as a fraction representing a rational number, so the result of the division of 26 by 11 is 2611{\displaystyle {\tfrac {26}{11}}} (or as a mixed number, so 2611=2411.{\displaystyle {\tfrac {26}{11}}=2{\tfrac {4}{11}}.}) Usually the resulting fraction should be simplified: the result of the division of 52 by 22 is also 2611{\displaystyle {\tfrac {26}{11}}}. This simplification may be done by factoring out the greatest common divisor.
^ Derbyshire, John (2004). Prime Obsession: Bernhard Riemann and the Greatest Unsolved Problem in Mathematics. New York City: Penguin Books. ISBN 978-0-452-28525-5.
Any of these forms can be used to display a fraction. A fraction is a division expression where both dividend and divisor are integers (typically called the numerator and denominator), and there is no implication that the division must be evaluated further. A second way to show division is to use the division sign (÷, also known as obelus though the term has additional meanings), common in arithmetic, in this manner:
^ a b Cajori, Florian (1929). A History of Mathematical Notations. Open Court Pub. Co.
Names and symbols used for integer division include div, /, \, and %. Definitions vary regarding integer division when the dividend or the divisor is negative: rounding may be toward zero (so called T-division) or toward −∞ (F-division); rarer styles can occur – see modulo operation for the details.
Jesper Carlström. "On Division by Zero" Archived 2019-08-17 at the Wayback Machine Retrieved October 23, 2018
In some non-English-speaking countries, a colon is used to denote division:[11]
where sgn(y) is the sign of y (except that, here, sgn(0) = 1). In particular, the imaginary parts of the original number and the principal value of its square root have the same sign. The real part of the principal value of the square root is always nonnegative.
A square root of 0 is either 0 or a zero divisor.Thus in rings where zero divisors do not exist, it is uniquely 0.However, rings with zero divisors may have multiple square roots of 0.For example, in Z/n2Z,{\displaystyle \mathbb {Z} /n^{2}\mathbb {Z} ,} any multiple of n is a square root of 0.
Joseph, George (2000). The Crest of the Peacock. Princeton: Princeton University Press. ISBN 0-691-00659-8.
According to Jeffrey A. Oaks, Arabs used the letter jīm/ĝīm (ج), the first letter of the word "جذر" (variously transliterated as jaḏr, jiḏr, ǧaḏr or ǧiḏr, "root"), placed in its initial form (ﺟ) over a number to indicate its square root. The letter jīm resembles the present square root shape. Its usage goes as far as the end of the twelfth century in the works of the Moroccan mathematician Ibn al-Yasamin.[12]
The most common iterative method of square root calculation by hand is known as the "Babylonian method" or "Heron's method" after the first-century Greek philosopher Heron of Alexandria, who first described it.[17]The method uses the same iterative scheme as the Newton–Raphson method yields when applied to the function y = f(x) = x2 − a, using the fact that its slope at any point is dy/dx = f′(x) = 2x, but predates it by many centuries.[18]The algorithm is to repeat a simple calculation that results in a number closer to the actual square root each time it is repeated with its result as the new input. The motivation is that if x is an overestimate to the square root of a nonnegative real number a then a/x will be an underestimate and so the average of these two numbers is a better approximation than either of them. However, the inequality of arithmetic and geometric means shows this average is always an overestimate of the square root (as noted below), and so it can serve as a new overestimate with which to repeat the process, which converges as a consequence of the successive overestimates and underestimates being closer to each other after each iteration. To find x:
Repeat from step 2, using this average as the new value of x.
Start with an arbitrary positive start value x. The closer to the square root of a, the fewer the iterations that will be needed to achieve the desired precision.
Handbook of mathematical functions with formulas, graphs, and mathematical tables
where the last equality, 1=−1,{\displaystyle {\sqrt {1}}=-1,} is a consequence of the choice of branch in the redefinition of √.
When the number is expressed using its real and imaginary parts, the following formula can be used for the principal square root:[21][22]
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Squares and Square Roots". www.mathsisfun.com. Retrieved 2020-08-28.
The principal square root function f(x)=x{\displaystyle f(x)={\sqrt {x}}} (usually just referred to as the "square root function") is a function that maps the set of nonnegative real numbers onto itself. In geometrical terms, the square root function maps the area of a square to its side length.
3Square roots of positive integers											Toggle Square roots of positive integers subsection																					3.1As decimal expansions																											3.2As expansions in other numeral systems																											3.3As periodic continued fractions
Mitchell, Douglas W., "Using Pythagorean triples to generate square roots of I2", Mathematical Gazette 87, November 2003, 499–500.
The time complexity for computing a square root with n digits of precision is equivalent to that of multiplying two n-digit numbers.
The construction is also given by Descartes in his La Géométrie, see figure 2 on page 2. However, Descartes made no claim to originality and his audience would have been quite familiar with Euclid.
Zill, Dennis G.; Shanahan, Patrick (2008). A First Course in Complex Analysis With Applications (2nd ed.). Jones & Bartlett Learning. p. 78. ISBN 978-0-7637-5772-4. Archived from the original on 2016-09-01. Extract of page 78 Archived 2016-09-01 at the Wayback Machine
"The Development of Algebra - 2". maths.org. Archived from the original on 24 November 2014. Retrieved 19 January 2015.
Most pocket calculators have a square root key. Computer spreadsheets and other software are also frequently used to calculate square roots. Pocket calculators typically implement efficient routines, such as the Newton's method (frequently with an initial guess of 1), to compute the square root of a positive real number.[14][15]When computing square roots with logarithm tables or slide rules, one can exploit the identities
Euclid's second proof in Book VI depends on the theory of similar triangles. Let AHB be a line segment of length a + b with AH = a and HB = b. Construct the circle with AB as diameter and let C be one of the two intersections of the perpendicular chord at H with the circle and denote the length CH as h. Then, using Thales' theorem and, as in the proof of Pythagoras' theorem by similar triangles, triangle AHC is similar to triangle CHB (as indeed both are to triangle ACB, though we don't need that, but it is the essence of the proof of Pythagoras' theorem) so that AH:CH is as HC:HB, i.e. a/h = h/b, from which we conclude by cross-multiplication that h2 = ab, and finally that h=ab{\displaystyle h={\sqrt {ab}}}. When marking the midpoint O of the line segment AB and drawing the radius OC of length (a + b)/2, then clearly OC > CH, i.e. a+b2≥ab{\textstyle {\frac {a+b}{2}}\geq {\sqrt {ab}}} (with equality if and only if a = b), which is the arithmetic–geometric mean inequality for two variables and, as noted above, is the basis of the Ancient Greek understanding of "Heron's method".
^ Maxwell, E. A. (1959). Fallacies in Mathematics. Cambridge University Press.
According to historian of mathematics D.E. Smith, Aryabhata's method for finding the square root was first introduced in Europe by Cataneo—in 1546.
In Ancient India, the knowledge of theoretical and applied aspects of square and square root was at least as old as the Sulba Sutras, dated around 800–500 BC (possibly much earlier).[7] A method for finding very good approximations to the square roots of 2 and 3 are given in the Baudhayana Sulba Sutra.[8]Aryabhata, in the Aryabhatiya (section 2.4), has given a method for finding the square root of numbers having many digits.
Every nonnegative real number x has a unique nonnegative square root, called the principal square root, which is denoted by x,{\displaystyle {\sqrt {x}},} where the symbol   {\displaystyle {\sqrt {~^{~}}}} is called the radical sign[2] or radix. For example, to express the fact that the principal square root of 9 is 3, we write 9=3{\displaystyle {\sqrt {9}}=3}. The term (or number) whose square root is being considered is known as the radicand. The radicand is the number or expression underneath the radical sign, in this case 9. For nonnegative x, the principal square root can also be written in exponent notation, as x1/2.
^ Mitchell, Douglas W., "Using Pythagorean triples to generate square roots of I2", Mathematical Gazette 87, November 2003, 499–500.
The symbol "√" for the square root was first used in print in 1525, in Christoph Rudolff's Coss.[13]
The square root of a positive integer is the product of the roots of its prime factors, because the square root of a product is the product of the square roots of the factors. Sincep2k=pk,{\displaystyle {\sqrt {p^{2k}}}=p^{k},} only roots of those primes having an odd power in the factorization are necessary. More precisely, the square root of a prime factorization is
In the Chinese mathematical work Writings on Reckoning, written between 202 BC and 186 BC during the early Han Dynasty, the square root is approximated by using an "excess and deficiency" method, which says to "...combine the excess and deficiency as the divisor; (taking) the deficiency numerator multiplied by the excess denominator and the excess numerator times the deficiency denominator, combine them as the dividend."[10]
where −π<θz≤π{\displaystyle -\pi <\theta _{z}\leq \pi } and −π<θw≤π{\displaystyle -\pi <\theta _{w}\leq \pi }.
^ Parkhurst, David F. (2006). Introduction to Applied Mathematics for Environmental Science. Springer. pp. 241. ISBN 9780387342283.
Abel–Ruffini theorem states that, in general, the roots of a polynomial of degree five or higher cannot be expressed in terms of nth roots.
Replace x by the average (x + a/x) / 2 between x and a/x.
the computation of the square root of a positive number can be reduced to that of a number in the range [1,4). This simplifies finding a start value for the iterative method that is close to the square root, for which a polynomial or piecewise-linear approximation can be used.
The square roots of small integers are used in both the SHA-1 and SHA-2 hash function designs to provide nothing up my sleeve numbers.
Wrongly assuming one of these laws underlies several faulty "proofs", for instance the following one showing that −1 = 1:
In a field of characteristic 2, an element either has one square root or does not have any at all, because each element is its own additive inverse, so that −u = u. If the field is finite of characteristic 2 then every element has a unique square root. In a field of any other characteristic, any non-zero element either has two square roots, as explained above, or does not have any.
Every positive number x has two square roots: x,{\displaystyle {\sqrt {x}},} which is positive, and −x,{\displaystyle -{\sqrt {x}},} which is negative. The two roots can be written more concisely using the ± sign as ±x{\displaystyle \pm {\sqrt {x}}}. Although the principal square root of a positive number is only one of its two square roots, the designation "the square root" is often used to refer to the principal square root.[3][4]
Anglin, W.S. (1994). Mathematics: A Concise History and Philosophy. New York: Springer-Verlag.
^ Abramowitz, Milton; Stegun, Irene A. (1964). Handbook of mathematical functions with formulas, graphs, and mathematical tables. Courier Dover Publications. p. 17. ISBN 0-486-61272-4. Archived from the original on 2016-04-23., Section 3.7.27, p. 17 Archived 2009-09-10 at the Wayback Machine
where ln and log10 are the natural and base-10 logarithms.
AMS Featured Column, Galileo's Arithmetic by Tony Philips – includes a section on how Galileo found square roots
if the branch includes −i, while the right-hand side becomes
Aitken, Mike; Broadhurst, Bill; Hladky, Stephen (2009). Mathematics for Biological Scientists. Garland Science. p. 41. ISBN 978-1-136-84393-8. Archived from the original on 2017-03-01. Extract of page 41 Archived 2017-03-01 at the Wayback Machine
The square roots of the perfect squares (e.g., 0, 1, 4, 9, 16) are integers. In all other cases, the square roots of positive integers are irrational numbers, and hence have non-repeating decimals in their decimal representations. Decimal approximations of the square roots of the first few natural numbers are given in the following table.
^ Overland, Brian (2013). C++ for the Impatient. Addison-Wesley. p. 338. ISBN 9780133257120. OCLC 850705706. Archived from the original on September 1, 2016. Retrieved June 24, 2016.
Abramowitz, Milton; Stegun, Irene A. (1964). Handbook of mathematical functions with formulas, graphs, and mathematical tables. Courier Dover Publications. p. 17. ISBN 0-486-61272-4. Archived from the original on 2016-04-23., Section 3.7.27, p. 17 Archived 2009-09-10 at the Wayback Machine
A square root can be constructed with a compass and straightedge. In his Elements, Euclid (fl. 300 BC) gave the construction of the geometric mean of two quantities in two different places: Proposition II.14 and Proposition VI.13.Since the geometric mean of a and b is ab{\displaystyle {\sqrt {ab}}}, one can construct a{\displaystyle {\sqrt {a}}} simply by taking b = 1.
The square root of a positive number is usually defined as the side length of a square with the area equal to the given number. But the square shape is not necessary for it: if one of two similar planar Euclidean objects has the area a times greater than another, then the ratio of their linear sizes is a{\displaystyle {\sqrt {a}}}.
It was known to the ancient Greeks that square roots of positive integers that are not perfect squares are always irrational numbers: numbers not expressible as a ratio of two integers (that is, they cannot be written exactly as mn{\textstyle {\frac {m}{n}}}, where m and n are integers). This is the theorem Euclid X, 9, almost certainly due to Theaetetus dating back to circa 380 BC.[9]The particular case of the square root of 2 is assumed to date back earlier to the Pythagoreans, and is traditionally attributed to Hippasus.[citation needed] It is exactly the length of the diagonal of a square with side length 1.
As with before, the square roots of the perfect squares (e.g., 0, 1, 4, 9, 16) are integers. In all other cases, the square roots of positive integers are irrational numbers, and therefore have non-repeating digits in any standard positional notation system.
A cube root of x{\displaystyle x} is a number y{\displaystyle y} such that y3=x{\displaystyle y^{3}=x}; it is denoted x3.{\displaystyle {\sqrt[{3}]{x}}.}
The above can also be expressed in terms of trigonometric functions:
The square root function is continuous for all nonnegative x, and differentiable for all positive x. If f denotes the square root function, whose derivative is given by:
The square root of a nonnegative number is used in the definition of Euclidean norm (and distance), as well as in generalizations such as Hilbert spaces. It defines an important concept of standard deviation used in probability theory and statistics. It has a major use in the formula for roots of a quadratic equation; quadratic fields and rings of quadratic integers, which are based on square roots, are important in algebra and have uses in geometry. Square roots frequently appear in mathematical formulas elsewhere, as well as in many physical laws.
^ Gel'fand, p. 120 Archived 2016-09-02 at the Wayback Machine
This page was last edited on 16 March 2023, at 07:53 (UTC).
^ Solow, Anita E. (1993). Learning by Discovery: A Lab Manual for Calculus. Cambridge University Press. pp. 48. ISBN 9780883850831.
For example, the principal square roots of ±i are given by:
The square of any positive or negative number is positive, and the square of 0 is 0. Therefore, no negative number can have a real square root.However, it is possible to work with a more inclusive set of numbers, called the complex numbers, that does contain solutions to the square root of a negative number.This is done by introducing a new number, denoted by i (sometimes by j, especially in the context of electricity where "i" traditionally represents electric current) and called the imaginary unit, which is defined such that i2 = −1. Using this notation, we can think of i as the square root of −1, but we also have (−i)2 = i2 = −1 and so −i is also a square root of −1. By convention, the principal square root of −1 is i, or more generally, if x is any nonnegative number, then the principal square root of −x is
^ "Function sqrt". CPlusPlus.com. The C++ Resources Network. 2016. Archived from the original on November 22, 2012. Retrieved June 24, 2016.
i=12+i12=22(1+i),−i=12−i12=22(1−i).{\displaystyle {\begin{aligned}{\sqrt {i}}&={\frac {1}{\sqrt {2}}}+i{\frac {1}{\sqrt {2}}}={\frac {\sqrt {2}}{2}}(1+i),\\{\sqrt {-i}}&={\frac {1}{\sqrt {2}}}-i{\frac {1}{\sqrt {2}}}={\frac {\sqrt {2}}{2}}(1-i).\end{aligned}}}
The third equality cannot be justified (see invalid proof).[23]: Chapter VI Some fallacies in algebra and trigonometry, Section I The fallacies, Subsection 2 The fallacy that +1 = -1  It can be made to hold by changing the meaning of √ so that this no longer represents the principal square root (see above) but selects a branch for the square root that contains 1⋅−1.{\displaystyle {\sqrt {1}}\cdot {\sqrt {-1}}.} The left-hand side becomes either
Cooke, Roger (2008). Classical algebra: its nature, origins, and uses. John Wiley and Sons. p. 59. ISBN 978-0-470-25952-8. Archived from the original on 2016-04-23.
The square bracket notation used above is a short form for a continued fraction. Written in the more suggestive algebraic form, the simple continued fraction for the square root of 11, [3; 3, 6, 3, 6, ...], looks like this:
: Chapter VI Some fallacies in algebra and trigonometry, Section I The fallacies, Subsection 2 The fallacy that +1 = -1
Maxwell, E. A. (1959). Fallacies in Mathematics. Cambridge University Press.
The definition of a square root of x{\displaystyle x} as a number y{\displaystyle y} such that y2=x{\displaystyle y^{2}=x} has been generalized in the following way.
Overland, Brian (2013). C++ for the Impatient. Addison-Wesley. p. 338. ISBN 9780133257120. OCLC 850705706. Archived from the original on September 1, 2016. Retrieved June 24, 2016.
One of the most intriguing results from the study of irrational numbers as continued fractions was obtained by Joseph Louis Lagrange c. 1780. Lagrange found that the representation of the square root of any non-square positive integer as a continued fraction is periodic. That is, a certain pattern of partial denominators repeats indefinitely in the continued fraction. In a sense these square roots are the very simplest irrational numbers, because they can be represented with a simple repeating pattern of integers.
For every non-zero complex number z there exist precisely two numbers w such that w2 = z: the principal square root of z (defined below), and its negative.
^ Zill, Dennis G.; Shanahan, Patrick (2008). A First Course in Complex Analysis With Applications (2nd ed.). Jones & Bartlett Learning. p. 78. ISBN 978-0-7637-5772-4. Archived from the original on 2016-09-01. Extract of page 78 Archived 2016-09-01 at the Wayback Machine
In mathematics, a square root of a number x is a number y such that y2 = x; in other words, a number y whose square (the result of multiplying the number by itself, or y ⋅ y) is x.[1] For example, 4 and −4 are square roots of 16, because 42 = (−4)2 = 16.
The square roots of an integer are algebraic integers—more specifically quadratic integers.
^ Aitken, Mike; Broadhurst, Bill; Hladky, Stephen (2009). Mathematics for Biological Scientists. Garland Science. p. 41. ISBN 978-1-136-84393-8. Archived from the original on 2017-03-01. Extract of page 41 Archived 2017-03-01 at the Wayback Machine
^ Muller, Jean-Mic (2006). Elementary functions: algorithms and implementation. Springer. pp. 92–93. ISBN 0-8176-4372-9., Chapter 5, p 92 Archived 2016-09-01 at the Wayback Machine
^ Cooke, Roger (2008). Classical algebra: its nature, origins, and uses. John Wiley and Sons. p. 59. ISBN 978-0-470-25952-8. Archived from the original on 2016-04-23.
Square roots of positive numbers are not in general rational numbers, and so cannot be written as a terminating or recurring decimal expression. Therefore in general any attempt to compute a square root expressed in decimal form can only yield an approximation, though a sequence of increasingly accurate approximations can be obtained.
^ "Analysis of YBC 7289". ubc.ca. Retrieved 19 January 2015.
Encyclopaedia of the History of Science, Technology, and Medicine in Non-Western Cultures
^ "The Development of Algebra - 2". maths.org. Archived from the original on 24 November 2014. Retrieved 19 January 2015.
By trial-and-error,[16] one can square an estimate for a{\displaystyle {\sqrt {a}}} and raise or lower the estimate until it agrees to sufficient accuracy. For this technique it is prudent to use the identity
Another method of geometric construction uses right triangles and induction: 1{\displaystyle {\sqrt {1}}} can be constructed, and once x{\displaystyle {\sqrt {x}}} has been constructed, the right triangle with legs 1 and x{\displaystyle {\sqrt {x}}} has a hypotenuse of x+1{\displaystyle {\sqrt {x+1}}}. Constructing successive square roots in this manner yields the Spiral of Theodorus depicted above.
That is, if an arbitrary guess for a{\displaystyle {\sqrt {a}}} is x0, and xn + 1 = (xn + a/xn) / 2, then each xn is an approximation of a{\displaystyle {\sqrt {a}}} which is better for large n than for small n. If a is positive, the convergence is quadratic, which means that in approaching the limit, the number of correct digits roughly doubles in each next iteration. If a = 0, the convergence is only linear.
Another example is provided by the ring of quaternions H,{\displaystyle \mathbb {H} ,} which has no zero divisors, but is not commutative.Here, the element −1 has infinitely many square roots, including ±i, ±j, and ±k.In fact, the set of square roots of −1 is exactly
The Yale Babylonian Collection YBC 7289 clay tablet was created between 1800 BC and 1600 BC, showing 2{\displaystyle {\sqrt {2}}} and 22=12{\textstyle {\frac {\sqrt {2}}{2}}={\frac {1}{\sqrt {2}}}} respectively as 1;24,51,10 and 0;42,25,35 base 60 numbers on a square crossed by two diagonals.[5] (1;24,51,10) base 60 corresponds to 1.41421296, which is a correct value to 5 decimal points (1.41421356...).
In the following, the complex z and w may be expressed as:
Because of the discontinuous nature of the square root function in the complex plane, the following laws are not true in general.
Seidenberg, A. (1961). "The ritual origin of geometry". Archive for History of Exact Sciences. 1 (5): 488–527. doi:10.1007/bf00327767. ISSN 0003-9519. S2CID 119992603. Seidenberg (pp. 501-505) proposes: "It is the distinction between use and origin." [By analogy] "KEPLER needed the ellipse to describe the paths of the planets around the sun; he did not, however invent the ellipse, but made use of a curve that had been lying around for nearly 2000 years". In this manner Seidenberg argues: "Although the date of a manuscript or text cannot give us the age of the practices it discloses, nonetheless the evidence is contained in manuscripts." Seidenberg quotes Thibaut from 1875: "Regarding the time in which the Sulvasutras may have been composed, it is impossible to give more accurate information than we are able to give about the date of the Kalpasutras. But whatever the period may have been during which Kalpasutras and Sulvasutras were composed in the form now before us, we must keep in view that they only give a systematically arranged description of sacrificial rites, which had been practiced during long preceding ages." Lastly, Seidenberg summarizes: "In 1899, THIBAUT ventured to assign the fourth or the third centuries B.C. as the latest possible date for the composition of the Sulvasutras (it being understood that this refers to a codification of far older material)."
The Rhind Mathematical Papyrus is a copy from 1650 BC of an earlier Berlin Papyrus and other texts – possibly the Kahun Papyrus – that shows how the Egyptians extracted square roots by an inverse proportion method.[6]
Dauben, Joseph W. (2007). "Chinese Mathematics I".In Katz, Victor J. (ed.). The Mathematics of Egypt, Mesopotamia, China, India, and Islam. Princeton: Princeton University Press. ISBN 978-0-691-11485-9.
Given an odd prime number p, let q = pe for some positive integer e. A non-zero element of the field Fq with q elements is a quadratic residue if it has a square root in Fq. Otherwise, it is a quadratic non-residue. There are (q − 1)/2 quadratic residues and (q − 1)/2 quadratic non-residues; zero is not counted in either class. The quadratic residues form a group under multiplication. The properties of quadratic residues are widely used in number theory.
"Function sqrt". CPlusPlus.com. The C++ Resources Network. 2016. Archived from the original on November 22, 2012. Retrieved June 24, 2016.
If A is a positive-definite matrix or operator, then there exists precisely one positive definite matrix or operator B with B2 = A; we then define A1/2 = B. In general matrices may have multiple square roots or even an infinitude of them.For example, the 2 × 2 identity matrix has an infinity of square roots,[24] though only one of them is positive definite.
^ Heath, Sir Thomas L. (1921). A History of Greek Mathematics, Vol. 2. Oxford: Clarendon Press. pp. 323–324.
x+iy=x2+y2+x2+isgn⁡(y)x2+y2−x2,{\displaystyle {\sqrt {x+iy}}={\sqrt {\frac {{\sqrt {x^{2}+y^{2}}}+x}{2}}}+i\operatorname {sgn}(y){\sqrt {\frac {{\sqrt {x^{2}+y^{2}}}-x}{2}}},}
Each element of an integral domain has no more than 2 square roots. The difference of two squares identity u2 − v2 = (u − v)(u + v) is proved using the commutativity of multiplication. If u and v are square roots of the same element, then u2 − v2 = 0. Because there are no zero divisors this implies u = v or u + v = 0, where the latter means that two roots are additive inverses of each other. In other words if an element a square root u of an element a exists, then the only square roots of a are u and −u. The only square root of 0 in an integral domain is 0 itself.
z∗=(z)∗{\displaystyle {\sqrt {z^{*}}}=\left({\sqrt {z}}\right)^{*}} Counterexample for the principal square root: z = −1)This equality is valid only when θz≠π{\displaystyle \theta _{z}\neq \pi }
Selin, Helaine (2008), Encyclopaedia of the History of Science, Technology, and Medicine in Non-Western Cultures, Springer, Bibcode:2008ehst.book.....S, ISBN 978-1-4020-4559-2.
Manguel, Alberto (2006). "Done on paper: the dual nature of numbers and the page". The Life of Numbers. ISBN 84-86882-14-1.
^ Seidenberg, A. (1961). "The ritual origin of geometry". Archive for History of Exact Sciences. 1 (5): 488–527. doi:10.1007/bf00327767. ISSN 0003-9519. S2CID 119992603. Seidenberg (pp. 501-505) proposes: "It is the distinction between use and origin." [By analogy] "KEPLER needed the ellipse to describe the paths of the planets around the sun; he did not, however invent the ellipse, but made use of a curve that had been lying around for nearly 2000 years". In this manner Seidenberg argues: "Although the date of a manuscript or text cannot give us the age of the practices it discloses, nonetheless the evidence is contained in manuscripts." Seidenberg quotes Thibaut from 1875: "Regarding the time in which the Sulvasutras may have been composed, it is impossible to give more accurate information than we are able to give about the date of the Kalpasutras. But whatever the period may have been during which Kalpasutras and Sulvasutras were composed in the form now before us, we must keep in view that they only give a systematically arranged description of sacrificial rites, which had been practiced during long preceding ages." Lastly, Seidenberg summarizes: "In 1899, THIBAUT ventured to assign the fourth or the third centuries B.C. as the latest possible date for the composition of the Sulvasutras (it being understood that this refers to a codification of far older material)."
Unlike in an integral domain, a square root in an arbitrary (unital) ring need not be unique up to sign.For example, in the ring Z/8Z{\displaystyle \mathbb {Z} /8\mathbb {Z} } of integers modulo 8 (which is commutative, but has zero divisors), the element 1 has four distinct square roots: ±1 and ±3.
1+x=∑n=0∞(−1)n(2n)!(1−2n)(n!)2(4n)xn=1+12x−18x2+116x3−5128x4+⋯,{\displaystyle {\sqrt {1+x}}=\sum _{n=0}^{\infty }{\frac {(-1)^{n}(2n)!}{(1-2n)(n!)^{2}(4^{n})}}x^{n}=1+{\frac {1}{2}}x-{\frac {1}{8}}x^{2}+{\frac {1}{16}}x^{3}-{\frac {5}{128}}x^{4}+\cdots ,}
wz=wz{\displaystyle {\frac {\sqrt {w}}{\sqrt {z}}}={\sqrt {\frac {w}{z}}}}Counterexample for the principal square root: w = 1 and z = −1 This equality is valid only when −π<θw−θz≤π{\displaystyle -\pi <\theta _{w}-\theta _{z}\leq \pi }
^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Squares and Square Roots". www.mathsisfun.com. Retrieved 2020-08-28.
11=3+26+26+26+26+26+⋱=3+620−1−120−120−120−120−⋱.{\displaystyle {\sqrt {11}}=3+{\cfrac {2}{6+{\cfrac {2}{6+{\cfrac {2}{6+{\cfrac {2}{6+{\cfrac {2}{6+\ddots }}}}}}}}}}=3+{\cfrac {6}{20-1-{\cfrac {1}{20-{\cfrac {1}{20-{\cfrac {1}{20-{\cfrac {1}{20-\ddots }}}}}}}}}}.}
The square root of x is rational if and only if x is a rational number that can be represented as a ratio of two perfect squares. (See square root of 2 for proofs that this is an irrational number, and quadratic irrational for a proof for all non-square natural numbers.) The square root function maps rational numbers into algebraic numbers, the latter being a superset of the rational numbers).
A symbol for square roots, written as an elaborate R, was invented by Regiomontanus (1436–1476). An R was also used for radix to indicate square roots in Gerolamo Cardano's Ars Magna.[11]
^ Anglin, W.S. (1994). Mathematics: A Concise History and Philosophy. New York: Springer-Verlag.
To find a definition for the square root that allows us to consistently choose a single value, called the principal value, we start by observing that any complex number x+iy{\displaystyle x+iy} can be viewed as a point in the plane, (x,y),{\displaystyle (x,y),} expressed using Cartesian coordinates. The same point may be reinterpreted using polar coordinates as the pair (r,φ),{\displaystyle (r,\varphi ),} where r≥0{\displaystyle r\geq 0} is the distance of the point from the origin, and φ{\displaystyle \varphi } is the angle that the line from the origin to the point makes with the positive real (x{\displaystyle x}) axis. In complex analysis, the location of this point is conventionally written reiφ.{\displaystyle re^{i\varphi }.} If
Another useful method for calculating the square root is the shifting nth root algorithm, applied for n = 2.
as it allows one to adjust the estimate x by some amount c and measure the square of the adjustment in terms of the original estimate and its square. Furthermore, (x + c)2 ≈ x2 + 2xc when c is close to 0, because the tangent line to the graph of x2 + 2xc + c2 at c = 0, as a function of c alone, is y = 2xc + x2. Thus, small adjustments to x can be planned out by setting 2xc to a, or c = a/(2x).
where the two-digit pattern {3, 6} repeats over and over again in the partial denominators. Since 11 = 32 + 2, the above is also identical to the following generalized continued fractions:
Muller, Jean-Mic (2006). Elementary functions: algorithms and implementation. Springer. pp. 92–93. ISBN 0-8176-4372-9., Chapter 5, p 92 Archived 2016-09-01 at the Wayback Machine
5Square roots of negative and complex numbers											Toggle Square roots of negative and complex numbers subsection																					5.1Principal square root of a complex number																											5.2Algebraic formula																											5.3Notes
A similar problem appears with other complex functions with branch cuts, e.g., the complex logarithm and the relations logz + logw = log(zw) or log(z*) = log(z)* which are not true in general.
^ * Oaks, Jeffrey A. (2012). Algebraic Symbolism in Medieval Arabic Algebra (PDF) (Thesis). Philosophica. p. 36. Archived (PDF) from the original on 2016-12-03.
Smith, David (1958). History of Mathematics. Vol. 2. New York: Dover Publications. ISBN 978-0-486-20430-7.
Heath, Sir Thomas L. (1921). A History of Greek Mathematics, Vol. 2. Oxford: Clarendon Press. pp. 323–324.
Algorithms, implementations, and more – Paul Hsieh's square roots webpage
Heath, Sir Thomas L. (1908). The Thirteen Books of The Elements, Vol. 3. Cambridge University Press. p. 3.
Given any polynomial p, a root of p is a number y such that p(y) = 0. For example, the nth roots of x are the roots of the polynomial (in y) yn−x.{\displaystyle y^{n}-x.}
^ Heath, Sir Thomas L. (1908). The Thirteen Books of The Elements, Vol. 3. Cambridge University Press. p. 3.
zw=zw{\displaystyle {\sqrt {zw}}={\sqrt {z}}{\sqrt {w}}} Counterexample for the principal square root: z = −1 andw = −1This equality is valid only when −π<θz+θw≤π{\displaystyle -\pi <\theta _{z}+\theta _{w}\leq \pi }
Gel'fand, Izrael M.; Shen, Alexander (1993). Algebra (3rd ed.). Birkhäuser. p. 120. ISBN 0-8176-3677-3.
The name of the square root function varies from programming language to programming language, with sqrt[19] (often pronounced "squirt" [20]) being common, used in C, C++, and derived languages like JavaScript, PHP, and Python.
If n is an integer greater than two, a nth root of x{\displaystyle x} is a number y{\displaystyle y} such that yn=x{\displaystyle y^{n}=x}; it is denoted xn.{\displaystyle {\sqrt[{n}]{x}}.}
* Oaks, Jeffrey A. (2012). Algebraic Symbolism in Medieval Arabic Algebra (PDF) (Thesis). Philosophica. p. 36. Archived (PDF) from the original on 2016-12-03.
The right side (as well as its negative) is indeed a square root of −x, since
^ Manguel, Alberto (2006). "Done on paper: the dual nature of numbers and the page". The Life of Numbers. ISBN 84-86882-14-1.
Square roots of negative numbers can be discussed within the framework of complex numbers. More generally, square roots can be considered in any context in which a notion of the "square" of a mathematical object is defined. These include function spaces and square matrices, among other mathematical structures.
The Taylor series of 1+x{\displaystyle {\sqrt {1+x}}} about x = 0 converges for |x| ≤ 1, and is given by
The principal square root function is holomorphic everywhere except on the set of non-positive real numbers (on strictly negative reals it is not even continuous). The above Taylor series for 1+x{\displaystyle {\sqrt {1+x}}} remains valid for complex numbers x{\displaystyle x} with |x|<1.{\displaystyle |x|<1.}
Solow, Anita E. (1993). Learning by Discovery: A Lab Manual for Calculus. Cambridge University Press. pp. 48. ISBN 9780883850831.
Parkhurst, David F. (2006). Introduction to Applied Mathematics for Environmental Science. Springer. pp. 241. ISBN 9780387342283.
